I"a<p>In the previous post we covered a method that approximates the Jaccard similarity by constructing a signature of the original representation. This allows us to significantly speed up the process of computing similarities between the sets. But remember that the goal is to find all similar items to a given item. This requires to compute the similarities between all pairs of items in the data. If we go back to our example, Spotify has about 1.2 million artists on their platform. Which means that to find all similar artists we need to make 1.4 trillion comparisons… ahm… how about no. We’re going to do something different. We’re instead going to use Locality Sensitive Hashing (LSH) to identify candidate pairs and only compute the similarities on those. This will substantially reduce the computational burden.</p>

<p>LSH is a neat method to find similar items without computing similarities between every pair. It accomplishes this by hashing items in such a way that results in similar items being hashed in the same bucket with high probability. If two items are hashed to the same bucket, we consider them as candidate pairs and proceed with computing their similarity.</p>

<h3>MinHash LSH</h3>

<p>The method that we’re going to describe relies on having a signature matrix of all of our sets precomputed. It is a pretty easy procedure both algorithmically and conceptually. It relies on the intuition that if two items have identical parts in some random positions then they’re probably similar. This is the idea we’re going to turn to, in order to identify candidate pairs.</p>

<p>We begin by dividing the signature matrix into \(b\) bands with \(r\) rows. We hash each item’s portion of the band with some hashing function <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>. We use the same hash function for every band but each band should have a separate array to store the buckets. If for a given band two items end up hashed into the same bucket, we consider them as candidate pairs. What this means is that if two items match each other on some portion of the signature we count them as candidates. Using a hashing function rather than directly comparing them is what allows us to avoid the quadratic amount of comparisons. Here’s a really simple implementation of an LSH for Jaccard similarities:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">minhash_lsh</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">num_rows</span> <span class="o">=</span> <span class="n">sig</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">bands</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">bands_buckets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">:</span>
        <span class="n">items_buckets</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">band</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">flatten</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">items_buckets</span><span class="p">[</span><span class="n">item</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">bands_buckets</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">items_buckets</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bands_buckets</span>
</code></pre></div></div>

<h3>Cosine LSH</h3>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>We can use the built-in hashing function of whatever programming language we’re using. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET