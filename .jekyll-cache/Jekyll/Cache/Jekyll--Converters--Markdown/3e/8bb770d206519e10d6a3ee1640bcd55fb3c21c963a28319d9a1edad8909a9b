I"Íó<ul>
  <li>
    <p><em>This post is best suited for people who are familiar with linear classifiers, specifically Logistic Regression. I will also be assuming that the reader is familiar with gradient descent</em></p>
  </li>
  <li>
    <p><em>The goal of this post isn‚Äôt to be a comprehensive guide about neural networks, rather this is an attempt to show an intuitive path, going from linear classifier to a simple neural network</em></p>
  </li>
</ul>

<p>There are many types of neural networks, each having some advantage over others. In this post I want to introduce the simplest form of a neural network, a Multilayer Perceptron (MLP). MLPs are a powerful method for approximating functions and it‚Äôs a simple model to implement (kinda‚Äô).</p>

<p>Before we jump into talking about MLPs, let‚Äôs quickly go over linear classifiers. Given training data as pairs <script type="math/tex">(\boldsymbol{x}_i, y_i)</script> where <script type="math/tex">\boldsymbol{x}_i \in \mathbb{R}^{d}</script> are datapoints (observations) and <script type="math/tex">y_i \in \{0, 1\}</script> are their corresponding class labels. The goal is to learn a vector of weights <script type="math/tex">\boldsymbol{w} \in \mathbb{R}^{d}</script> and a bias <script type="math/tex">b \in \mathbb{R}</script> such that <script type="math/tex">\boldsymbol{w}^T\boldsymbol{x}_{i} + b \ge 0</script> if <script type="math/tex">y_{i} = 1</script> and <script type="math/tex">% <![CDATA[
\boldsymbol{w}^T\boldsymbol{x}_{i} + b < 0 %]]></script> otherwise (<script type="math/tex">y_{i} = 0</script>). This decision can be summarized as the following step function:</p>

<script type="math/tex; mode=display">% <![CDATA[
\text{Prediction} = \begin{cases}
      1 & \boldsymbol{w}^T\boldsymbol{x} + b \ge 0 \\
      0 &  \text{Otherwise}\\
\end{cases} %]]></script>

<p>In the case of Logistic Regression the decision function is characterized by the sigmoid function <script type="math/tex">\sigma(z) = \frac{1}{1+e^{-z}}</script> where <script type="math/tex">z = \boldsymbol{w}^T\boldsymbol{x} + b</script></p>

<script type="math/tex; mode=display">% <![CDATA[
\text{Prediction} = \begin{cases}
      1 & \sigma(z) \ge \theta \\
      0 &  \text{Otherwise}\\
\end{cases} %]]></script>

<p>Where <script type="math/tex">\theta</script> is a threshold that is usually set to be 0.5.</p>

<!-- *Note: These are actually just a couple of examples of a zoo of functions that people in deep learning literature refer to as activation functions.* -->

<p>If the dataset is linearly separable this is all fine, since we can always learn <script type="math/tex">\boldsymbol{w}</script> and <script type="math/tex">b</script> that separates the data perfectly. We‚Äôre in good shape even if the dataset is almost linearly separable, i.e the data points can be separated with a line, barring a few noisy observations.</p>

<p><img src="../images/blobs.png" alt="" /></p>

<p>But what can we do if the dataset is highly non-linear? For example something like this:</p>

<p><img src="../images/circles.png" alt="" /></p>

<p>One thing we could potentially do is to come up with some non-linear transformation function <script type="math/tex">\phi(\boldsymbol{x})</script>, such that applying it, renders the data linearly separable. Having this transformation function would allow us to use all the tools we have for linear classification.</p>

<!-- We can then apply that transformation to the original dataset and learn a linear classifier on the transformed dataset. -->

<p>For example in this case we can see that the data points come from two concentric circles. Using this information we define the following transformation function: <script type="math/tex">\phi(\boldsymbol{x}) = [x_1^2, x_2^2]</script></p>

<p>Now we can learn a vector <script type="math/tex">\boldsymbol{w}</script> and bias <script type="math/tex">b</script> such that <script type="math/tex">\boldsymbol{w}^T\phi(\boldsymbol{x}_{i}) + b \ge 0</script> if <script type="math/tex">y_{i} = 1</script> and <script type="math/tex">% <![CDATA[
\boldsymbol{w}^T\phi(\boldsymbol{x}_{i}) + b < 0 %]]></script> otherwise.</p>

<p><img src="../images/circles_transformed_clf.png" alt="" /></p>

<p>This works for this particular case because we know exactly what the data generation process is, But what can we do when it‚Äôs not obvious what the underlying function is? What if we‚Äôre working in high dimensions where we can‚Äôt visualize the shape of the dataset? In general it‚Äôs hard to come up with these transformation functions.</p>

<p>Here‚Äôs another idea, instead of learning one linear classifier, let‚Äôs try to learn three linear classifiers and then combine them to get something like this:</p>

<p><img src="../images/circles3.png" alt="" /></p>

<p>We know how to learn a single linear classifier but how can we learn three linear classifiers that can produce a result like this? The naive approach would be to try to learn them independently using different random initializations and hope that they converge to something like what we want. But this approach is doomed from the beginning since each classifier will try to fit the whole data while ignoring what the other classifiers are doing. In other words there will be no cooperation since none of the classifiers will be ‚Äúaware‚Äù of each other. This is the opposite of what we want. We want/need the classifiers to work together.</p>

<p>This is where MLPs come in. A simple MLP can actually do both of the aforementioned things. 1) It can learn a non-linear transformation that makes the dataset linearly separable and 2) it can learn multiple linear classifiers that cooperate.</p>

<p>The goal for the next section is to come up with a classifier that can potentially learn how to correctly classify the two concentric circles dataset.</p>

<!-- **Neural Networks:**

By far the most common way of introducing neural networks is with the notion of computational graphs. While I do think that computational graphs are an important concept to understand, I do not think that they are the best way to be introduced to neural networks. Instead I will be using concepts that hopefully you the reader are familiar with. These are the essential operations for neural networks: matrix multiplication, non-linear activation functions and function composition. -->

<!-- In general it's better to teach new ideas using concepts and terms that a person is already familiar with, since this allows for the already known things to function as a foundation to be built on, rather than trying build from scratch.

The term 'neural networks' itself is kind of misleading. It creates an image of a brain like structure and it feeds into the whole hype about AI taking over. Neural networks in reality are nothing but a chain of matrix multiplications followed by non-linear functions.   -->

<h2 id="forward">Forward</h2>

<h4 id="three-linear-classifiers">Three Linear Classifiers</h4>

<p>Let‚Äôs continue our idea of learning multiple linear classifiers. Define three classifiers <script type="math/tex">(\boldsymbol{w}_{1}, b_1), (\boldsymbol{w}_{2}, b_3)</script> and <script type="math/tex">(\boldsymbol{w}_{3}, b_3)</script>, where <script type="math/tex">\boldsymbol{w}_i \in \mathbb{R}^2</script> and <script type="math/tex">b_i \in \mathbb{R}</script>.</p>

<p>Because we want to learn all three jointly, it makes sense to combine them into a single object. Let‚Äôs stack all of the classifiers into a single matrix <script type="math/tex">\boldsymbol{W}^{3 \times 2}</script> and the biases into a vector <script type="math/tex">\boldsymbol{b}^{3 \times 1}</script>, as such:</p>

<script type="math/tex; mode=display">% <![CDATA[
\boldsymbol{W} = \begin{bmatrix}
           \boldsymbol{w}^T_{1} \\
           \boldsymbol{w}^T_{2} \\
           \boldsymbol{w}^T_{3} \\
         \end{bmatrix} = \begin{bmatrix}
                    w_1^{(1)} & w_1^{(2)}\\
                    w_2^{(1)} & w_2^{(2)}\\
                    w_3^{(1)} & w_3^{(2)}\\
                  \end{bmatrix} \boldsymbol{b} = \begin{bmatrix}
                             b_1 \\
                             b_2 \\
                             b_3 \\
                           \end{bmatrix} %]]></script>

<p>Now we need to get a classification decision from each one of the classifiers. We mentioned two types of decision functions in the beginning of the post, the step function and the sigmoid, which is basically a smooth step function. For technical reasons that will become clear in the next section, we‚Äôre gonna use the sigmoid function to produce decisions. For each pair <script type="math/tex">(\boldsymbol{w}_{i}, b_i)</script>, to get the prediction for a given data point we take <script type="math/tex">\sigma(\boldsymbol{w}_{i}^T\boldsymbol{x} + b_i)</script>. But this is not taking the advantage of having everything packed into a matrix. Instead of enumerating the classifiers one by one we could do everything in one operation.</p>

<script type="math/tex; mode=display">\sigma(\boldsymbol{Wx} + \boldsymbol{b}) = \begin{bmatrix}
\sigma(\boldsymbol{w}_{1}\boldsymbol{x} + b_1) \\
\sigma(\boldsymbol{w}_{2}\boldsymbol{x} + b_2) \\
\sigma(\boldsymbol{w}{3}\boldsymbol{x} + b_3) \\
\end{bmatrix}</script>

<p><em>Note: We are slightly abusing the notation here, but just to be clear, <script type="math/tex">\sigma</script> function for vector valued functions is an element-wise operation.</em></p>

<p>This is great, but so far we haven‚Äôt really done anything. We just came up with a neat way to compute the output of all three classifiers given some input. We still need to connect them in order to create ‚Äúcooperation‚Äù.</p>

<h4 id="the-meta-classifier">The Meta Classifier</h4>

<p>Let‚Äôs define another linear classifier, but this time instead of taking the data points as input, this classifier will take the outputs of the three classifiers as input and will output a final classification decision. In a way it‚Äôs a meta classifier, since it classifies using outputs of other classifiers.</p>

<p>Let <script type="math/tex">\boldsymbol{h}^{3 \times 1}</script> be the output of the previous classifiers, i.e <script type="math/tex">\boldsymbol{h} = \sigma(\boldsymbol{Wx} + \boldsymbol{b})</script>, then the prediction of the meta classifier <script type="math/tex">(\boldsymbol{w}_{m}, b_{m})</script> is defined as: <script type="math/tex">\sigma(\boldsymbol{w}_{m}^T\boldsymbol{h} + b_{m})</script>, where <script type="math/tex">\boldsymbol{w}_{m} \in \mathbb{R}^3</script> and <script type="math/tex">b_{m} \in \mathbb{R}</script>.</p>

<!-- This classifier will have 2 jobs: 1) combine outputs in the forward pass and 2) act as a "conductor" by ensuring coordination during the backward pass. -->
<!--
This classifier which is kind of a meta classifier, will essentially act as a conductor, making sure there is coordination between the previous three classifiers. -->

<p>And there it is, we finally have everything. All three classifiers are connected, we have a way to produce a single prediction using all three of them and there is hope that coordination will happen because of the meta classifier.</p>

<p>Just to recap, the expression bellow is the function that corresponds to our MLP:</p>

<script type="math/tex; mode=display">\text{MLP}(\boldsymbol{x}; \boldsymbol{w}_{m}, b_{m}, \boldsymbol{W}, \boldsymbol{b}) =\sigma(\boldsymbol{w}_{m}^T\sigma(\boldsymbol{Wx} + \boldsymbol{b}) + b_{m})</script>

<p>Everything before the semicolon is the input of the function and everything after are the parameters of the function. Our goal is to learn the parameters.</p>

<p><strong>Exercise:</strong>
A question that you might have at this point is ‚Äúwhy do we need to have a decision function applied to the three linear classifiers, can‚Äôt we directly plug the outputs to the meta classifier and produce a decision? ‚Äú. I‚Äôm gonna leave the answer to that as an exercise. Remove all the <script type="math/tex">\sigma</script> functions, and simplify the expression. What do you get? Is it different than having a single linear classifier?</p>

<!-- A layer in the context of an MLP is nothing but a linear transformation followed by an activation function. We will use our idea of learning multiple classifiers but instead of looking at them independently, we'll define them together as a single layer.

Let's define three classifiers $$(\boldsymbol{w_1}, b_1), (\boldsymbol{w_2}, b_3)$$ and $$(\boldsymbol{w_3}, b_3)$$. For compactness, let's combine all of the weights into a single matrix and all of the biases into a vector.

$$\boldsymbol{W} = \begin{bmatrix}
           \boldsymbol{w_1} \\
           \boldsymbol{w_2} \\
           \boldsymbol{w_3} \\
         \end{bmatrix} = \begin{bmatrix}
                    w_1^{(1)} & w_1^{(2)}\\
                    w_2^{(1)} & w_2^{(2)}\\
                    w_3^{(1)} & w_3^{(2)}\\
                  \end{bmatrix} \boldsymbol{b} = \begin{bmatrix}
                             b_1 \\
                             b_2 \\
                             b_3 \\
                           \end{bmatrix}$$ -->

<!-- Now we need to get the classification decision from all three classifiers. We might be tempted to use the step function but for technical reasons, that will become clear later on, we require the function to be differentiable and since the step function is not, we cannot use it. We could however use the sigmoid.

The classification decision from each of the classifiers can then be obtained by applying $$\sigma$$ element-wise to each of the three outputs.

$$\sigma(\boldsymbol{Wx} + \boldsymbol{b}) = \begin{bmatrix}
\sigma(\boldsymbol{w_1x} + b_1) \\
\sigma(\boldsymbol{w_2x} + b_2) \\
\sigma(\boldsymbol{w_3x} + b_3) \\
\end{bmatrix}$$

Notice that what we have is a linear transformation $$\boldsymbol{s} = \boldsymbol{Wx} + \boldsymbol{b}$$, followed by a non-linear activation $$\boldsymbol{h} = \sigma(\boldsymbol{s})$$. -->

<!-- *In the neural network lingo what we defined above is a hidden layer with 3 sigmoid units. Note that we need not use sigmoid here. As I mentioned in the beginning of this post, the sigmoid function is just one example of many activation functions. We could use anything we want (as long as it's differentiable). Here are a few alternatives: Tanh, ReLu, LeakyReLu etc. The most popular choice in practice is the ReLu activation defined as $$\text{ReLu}(z)=\max(0, z)$$.* -->

<!-- **Second Layer**

The first layer gives us outputs from the classifiers but we still need a way to combine them into one final classification decision. For example if the outputs from the layer are $$[0.7, 0.5, 0.1]$$ what should the classification decision be?

Let's define another classifier $$(\boldsymbol{w}_{final}, b_{final})$$ that will take the outputs of the three classifiers as input and will produce a final output: $$\boldsymbol{w}_{final}^T\sigma(\boldsymbol{Wx} + \boldsymbol{b}) + b_{final}$$

And finally in order to get the final classification decision, we apply a sigmoid activation to the result of this as well. Combining all the parts we get that our function is defined as:

 $$\text{MLP}(\boldsymbol{x}) =\sigma(\boldsymbol{w}_{final}^T\sigma(\boldsymbol{Wx} + \boldsymbol{b}) + b_{final})$$

This one line actually fully defines our two-layer MLP. -->

<!-- **Why do we need activations?**

When I defined the first layer, I said that we needed to get a classification decision from each of the classifiers. This isn't quite right. We don't need a classification decision. What we actually need is a response. A response that is non-linear in the input. Non-linear activation functions are actually what makes this whole thing work. If for example in our hidden layer we removed the $$\sigma$$ activation and replaced it with an identity, the MLP will actually become a linear classifier which would mean that we will not be able represent the non-linear shape of the input data. To convince yourself, write out the MLP without any activations and see that it reduces to a linear function. -->

<!-- **More layers**

In practice we usually have many such layers each connected to each other, i.e the output of one becomes the input for to next one. Chaining layers like this is actually the same as function composition. If we define each layer as a function, $$f_i(x) = g(\boldsymbol{W}_i\boldsymbol{x}+b_i)$$, where $$g$$ is some non-linear activation then an n-layer MLP can be written as the function composition $$MLP(x) = f_n(f_{n-1}(...(f_1(x))) $$. The depth of a network corresponds to $$n$$, when $$n > 2$$, people refer to this network as deep (this is where the term deep learning comes from). The width of a network corresponds to the number of units in each of the layer.

The functions $$f_1,f_2, ..., f_{n-1}$$ are all learning a transformations with the ultimate goal to make the input $$X$$ linearly separable for the final layer $$f_n$$. This is the essence of deep learning. Every neural network one way or another is trying to learn a transformation function on the input space that can render the data linearly separable. -->

<h2 id="backward">Backward</h2>

<!-- *You are free to skip ahead this section if you don't care about knowing all the nitty gritty details of learning the parameters of the MLP.* -->

<p>We have managed to define a simple MLP but we still need a way to learn the parameters of the function. The function is fully differentiable and this is no accident. As I said earlier, we chose to use the sigmoid function instead of the step-function as a decision function because of technical reasons. Well the technical reason is that, differentiability is nice and we like it because it allows us to use gradient based optimization algorithms like gradient descent.</p>

<h4 id="loss-function">Loss Function</h4>

<p>Since the function is differentiable, we can define a loss function and then start optimizing with respect to the learnable parameters using gradient descent. Notice that the output of the MLP is a real number between 0 and 1. What we‚Äôre essentially doing is modeling the conditional distribution
<script type="math/tex">P(y | \boldsymbol{x})</script> with a parametrized function <script type="math/tex">MLP(\boldsymbol{x}; \theta)</script> <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>. This means that we can use the principle of maximum likelihood to estimate the parameters.</p>

<script type="math/tex; mode=display">L(y, \hat{y}) = \frac{1}{n} \sum_{i=1}^n -y_i\log\hat{y_i} - (1-y_i)\log(1-\hat{y_i})</script>

<p>Where <script type="math/tex">\hat{y} = MLP(\boldsymbol{x}; \theta)</script>. The objective is to minimize <script type="math/tex">L(y, \hat{y})</script> <sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> with respect to the learnable parameters <script type="math/tex">\theta</script>.</p>

<h4 id="optimization">Optimization</h4>

<p>The plan is to use gradient descent to optimize <script type="math/tex">L</script>. Remember that during gradient descent, we need take the gradient (hence the name) of the objective at every step of the algorithm.</p>

<script type="math/tex; mode=display">\theta \leftarrow \theta - \alpha \nabla_{\theta} L</script>

<p>Where <script type="math/tex">\alpha</script> is the step size (learning rate).</p>

<p>Since <script type="math/tex">L</script> is a composition function, we will need to use the chain rule (Remember Calc 1). Furthermore, <script type="math/tex">\theta</script> isn‚Äôt a single variable, we will be optimizing with respect to 4 different variables <script type="math/tex">\boldsymbol{w}_{m}, b_{m}, \boldsymbol{W}, \boldsymbol{b}</script>. We‚Äôre going to need to update each one at every step:</p>

<p><script type="math/tex">\boldsymbol{w}_{m} \leftarrow \boldsymbol{w}_{m} - \alpha * \frac{\partial L}{\partial \boldsymbol{w}_{m}}</script> <br />
  <script type="math/tex">b_{m} \leftarrow b_{m} - \alpha * \frac{\partial L}{\partial b_{m}}</script> <br />
  <script type="math/tex">\boldsymbol{W} \leftarrow \boldsymbol{W} - \alpha * \frac{\partial L}{\partial \boldsymbol{W}}</script> <br />
  <script type="math/tex">\boldsymbol{b} \leftarrow \boldsymbol{b} - \alpha * \frac{\partial L}{\partial \boldsymbol{b}}</script></p>

<h4 id="derivatives-derivatives-derivatives">Derivatives, Derivatives, Derivatives</h4>

<p><em>Skip this section if you don‚Äôt care about all of the gory details of computing the partials. Although I do think that it‚Äôs a good idea to do this at least once by hand.</em></p>

<p>Now we will need to breakdown each of the partial derivatives using the chain rule. If we‚Äôre not careful about giving names to intermediate values, it will quickly get hairy. So let‚Äôs do that first.</p>

<p><script type="math/tex">\boldsymbol{s}_1 = \boldsymbol{Wx} + \boldsymbol{b}</script> <br />
  <script type="math/tex">\boldsymbol{h} = \sigma(\boldsymbol{s}_1)</script> <br />
  <script type="math/tex">s_2 = \boldsymbol{w}^T_{m}\boldsymbol{h} + b_{m}</script> <br />
  <script type="math/tex">\hat{y} = \sigma(s_2) = MLP(\boldsymbol{x})</script></p>

<!-- Okay now that we have our intermediate values named, let's define the loss function. We're going to be using binary cross-entropy (negative log likelihood) which is defined as:

$$ L(y, \hat{y}) = \frac{1}{n} \sum_{i=1}^n -y_i\log\hat{y_i} - (1-y_i)\log(1-\hat{y_i})$$ -->

<p>Before we start the tedious process of taking partial derivatives of a composed function I want to remind you that the goal is to compute these four partial derivatives: <script type="math/tex">\frac{\partial L}{\partial \boldsymbol{w}_{m}}, \frac{\partial L}{\partial b_{m}}, \frac{\partial L}{\partial \boldsymbol{W}}, \frac{\partial L}{\partial \boldsymbol{b}}</script>. If we have these values, we can use them to update the parameters at each step of gradient descent. Using the chain rule we can write down each of the partial derivatives as a product:</p>

<p><script type="math/tex">\frac{\partial L}{\partial \boldsymbol{w}_{m}} = \frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial \boldsymbol{w}_{m}}</script> <br />
  <script type="math/tex">\frac{\partial L}{\partial b_{m}} = \frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial b_{m}}</script> <br />
  <script type="math/tex">\frac{\partial L}{\partial \boldsymbol{W}} = \frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial \boldsymbol{h}}\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s}_1}\frac{\partial \boldsymbol{s}_1}{\partial \boldsymbol{W}}</script> <br />
  <script type="math/tex">\frac{\partial L}{\partial \boldsymbol{b}} = \frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial \boldsymbol{h}}\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s}_1}\frac{\partial \boldsymbol{s}_1}{\partial \boldsymbol{b}}</script></p>

<p>I know this looks complex but it really isn‚Äôt that complicated. All we‚Äôre doing is taking a partial derivative of the loss with respect to each of the learnable parameters. Since the loss is a composition function we have to use chain rule. That‚Äôs it.</p>

<p>We can see that <script type="math/tex">\frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}</script> is shared among all of them and that <script type="math/tex">L, \hat{y}, s_2</script> are all scalar variables therefore the derivatives are relatively easy to compute.</p>

<p><script type="math/tex">\frac{\partial L}{\partial \hat{y}} = \frac{\hat{y}-y}{\hat{y}(1-\hat{y})}</script> <br />
  <script type="math/tex">\frac{\partial \hat{y}}{\partial s_2} = \hat{y}(1-\hat{y})</script> (Recall that <script type="math/tex">\sigma^{'}(z) = (1-\sigma(z))\sigma(z)</script>)</p>

<p>Hence <script type="math/tex">\frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2} = \hat{y}-y</script>.</p>

<p>Continuing down the chain we get:</p>

<p><script type="math/tex">\frac{\partial s_2}{\partial \boldsymbol{w}_{m}} = \boldsymbol{h}</script> <br />
  <script type="math/tex">\frac{\partial s_2}{\partial b_{m}} = 1</script> <br />
  <script type="math/tex">\frac{\partial s_2}{\partial \boldsymbol{h}} = \boldsymbol{w}_{m}</script></p>

<p>Now since, <script type="math/tex">\boldsymbol{h}</script> and <script type="math/tex">\boldsymbol{s_1}</script> are both vectors, the partial <script type="math/tex">\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s_1}}</script> will be a matrix, however it will be a diagonal matrix.</p>

<script type="math/tex; mode=display">\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s_1}} = \text{diag}((\boldsymbol{1} - \boldsymbol{h}) \odot \boldsymbol{h})</script>

<p>Which can be replaced by an element-wise multiplication in the chain as: <script type="math/tex">\odot (\boldsymbol{1} - \boldsymbol{h}) \odot \boldsymbol{h}</script></p>

<p>The partial derivative <script type="math/tex">\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{W}}</script> is the most complicated to compute. <script type="math/tex">\boldsymbol{s_1}</script> is a vector and <script type="math/tex">\boldsymbol{W}</script> is a matrix, therefore the result of the partial derivative will be a 3 dimensional tensor! But fortunately, we will be able to reduce it to something more simple.</p>

<p>Instead of computing the partial derivative with respect to entire weight matrix, let‚Äôs instead take derivatives with respect to each of the classifiers <script type="math/tex">\boldsymbol{w_1}, \boldsymbol{w_2},</script> and <script type="math/tex">\boldsymbol{w_3}</script> (These would correspond to the rows of <script type="math/tex">\boldsymbol{W}</script>). Each of these derivatives will be a matrix instead of a tensor.</p>

<p><script type="math/tex">% <![CDATA[
\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_1}} = \begin{bmatrix}
             x_1 && x_2\\
             0 && 0 \\
             0 && 0 \\
           \end{bmatrix} %]]></script> <br />
  <script type="math/tex">% <![CDATA[
\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_2}} = \begin{bmatrix}
            0 && 0\\
            x_1 && x_2 \\
            0 && 0 \\
          \end{bmatrix} %]]></script> <br />
  <script type="math/tex">% <![CDATA[
\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_3}} = \begin{bmatrix}
            0 && 0\\
            0 && 0 \\
            x_1 && x_2 \\
          \end{bmatrix} %]]></script></p>

<p>We know that we‚Äôre gonna be using these values in a multiplication. We can use this fact to simplify the expression for the derivative. Let <script type="math/tex">\frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial \boldsymbol{h}}\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s}_1} = \boldsymbol{\delta}</script>, then we‚Äôll have</p>

<p><script type="math/tex">\boldsymbol{\delta} \frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_1}} = [\delta_1x_1, \delta_1x_2]</script> <br />
  <script type="math/tex">\boldsymbol{\delta} \frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_2}} = [\delta_2x_1, \delta_2x_2]</script> <br />
  <script type="math/tex">\boldsymbol{\delta} \frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_3}} = [\delta_3x_1, \delta_3x_2]</script></p>

<p>Which implies that <script type="math/tex">% <![CDATA[
\boldsymbol{\delta}\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{W}} = \begin{bmatrix}
          \delta_1x_1 && \delta_1x_2\\
          \delta_2x_1 && \delta_2x_2 \\
          \delta_3x_1 && \delta_3x_2 \\
        \end{bmatrix} %]]></script></p>

<p>We can rewrite this compactly as an <em>outer product</em> between <script type="math/tex">\boldsymbol{\delta}</script> and <script type="math/tex">\boldsymbol{x}</script>.</p>

<script type="math/tex; mode=display">\frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial \boldsymbol{h}}\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s}_1}\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{W}} = \boldsymbol{\delta} \otimes \boldsymbol{x}</script>

<p>And finally</p>

<script type="math/tex; mode=display">\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{b}} = \text{diag}(\boldsymbol{1}) = \boldsymbol{I}</script>

<p>Putting everything together:</p>

<p><script type="math/tex">\frac{\partial L}{\partial \boldsymbol{w}_{m}} = (\hat{y} - y)\boldsymbol{h}</script> <br />
  <script type="math/tex">\frac{\partial L}{\partial b_{m}} = \hat{y} - y</script> <br />
  <script type="math/tex">\frac{\partial L}{\partial \boldsymbol{W}} = ((\hat{y} - y)\boldsymbol{w}_{m}\odot (\boldsymbol{1} - \boldsymbol{h}) \odot \boldsymbol{h}) \otimes \boldsymbol{x}</script> <br />
  <script type="math/tex">\frac{\partial L}{\partial \boldsymbol{b}} = ((\hat{y} - y)\boldsymbol{w}_{m}\odot (\boldsymbol{1} - \boldsymbol{h}) \odot \boldsymbol{h})^T</script></p>

<p>You may have noticed that all of this is for a single datapoint <script type="math/tex">\boldsymbol{x}</script>, we wouldn‚Äôt do this in practice. It is much more preferable to have everything computed for a batch of inputs <script type="math/tex">\boldsymbol{X}</script>, this allows us to update the parameters much more efficiently. I highly recommend you redo all of the computations of the partial derivatives in matrix form.</p>

<p>I‚Äôve also purposefully skipped over a lot of the details. I wanted this block of the post to serve as a reference for your own solutions rather than a complete step-by-step guide. Here are some useful notes that can come in handy if you want to do everything from scratch:</p>

<ul>
  <li><a href="http://cs231n.stanford.edu/vecDerivs.pdf">Vector, Matrix, and Tensor Derivatives - Erik Learned-Miller</a></li>
  <li><a href="https://web.stanford.edu/class/cs224n/readings/gradient-notes.pdf">Computing Neural Network Gradients - Kevin Clark</a></li>
</ul>

<h2 id="analysis">Analysis</h2>
<p>Phew! now that‚Äôs over with. Let‚Äôs see what the results after running gradient descent (1000 iterations with a learning rate of 0.01). Do you remember how we started? We said that if only we had a transformation function that could make the dataset linearly separable then learning would be easy. Well <script type="math/tex">\phi(\boldsymbol{x}) = \sigma(\boldsymbol{Wx} + \boldsymbol{b})</script> will actually be that transformation that makes the dataset linearly separable. This is what the data looks like after applying that learned function:</p>

<p><img src="../images/projection.png" alt="" /></p>

<p>As you can see the data is completely linearly separable. In essence, this is what most of learning is when it comes to neural networks. Every neural network classifier that has classification as a primary task is trying to learn some kind of a transformation on the data so that the data becomes linearly separable. This is a big reason why neural networks became so popular. In the past people (usually domain experts) spent tremendous efforts in engineering features to make learning easy. Now a lot of that is handled by (deep) neural networks <sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>.</p>

<p>We were also trying to learn multiple linear classifiers. and voil√†, these are the three linear classifiers <script type="math/tex">(\boldsymbol{w}_{1}, b_1), (\boldsymbol{w}_{2}, b_3)</script> and <script type="math/tex">(\boldsymbol{w}_{3}, b_3)</script> that are learned:</p>

<p><img src="../images/hidden_classifiers.png" alt="" /></p>

<p>And finally this is what the learned decision boundary looks like in the original space. The colors indicate the predictions of the classifier.</p>

<p><img src="../images/decision_boundary.png" alt="" /></p>

<p>This is awesome isn‚Äôt it? but wait hold on. While this classifier gets 100% accuracy, it does not represent the true function‚Ä¶</p>

<p>Does that bother you?</p>

<h2 id="jargon">Jargon</h2>

<p>For the entirety of the post I have purposefully avoided mentioning neural network jargon that you usually see in the literature. I think some of the terms itself can bring a lot of confusion to people when they first get introduced to neural networks. However, since the field is set on using these terms, it‚Äôs necessary to know them. Let‚Äôs go back and put names on some of the things we‚Äôve talked about.</p>

<h3 id="activation-functions">Activation Functions</h3>

<p>We talked about decision functions. We mentioned the step function and the sigmoid function. The justification for having them was straight-forward since we were talking in the context of classifiers and we had to have a function that produces a prediction. But in the context of neural networks we don‚Äôt really care for predictions if it isn‚Äôt the last classifier (the meta-classifier). Every intermediate function can have any form, as long as it‚Äôs differentiable.</p>

<p>So we weren‚Äôt constrained to using sigmoid, here are a few others we could have used: Tanh, ReLu, LeakyReLu etc. People refer to these functions as activation functions. The most popular choice in practice is the ReLu activation defined as <script type="math/tex">\text{ReLu}(z)=\max(0, z)</script>. Activation functions are usually non-linear and they are almost always applied element-wise to the inputs. The non-linearity of the activation functions is the reason why neural networks are able to learn non-linear functions.</p>

<h3 id="neuron-or-unit">Neuron or Unit</h3>

<p>As we mentioned above, we don‚Äôt really need to predict in the intermediate operations. Therefore, we probably shouldn‚Äôt be calling these functions classifiers. People usually call these functions neurons or units. I prefer to call them units since calling to them neurons is drawing a parallel to biological neurons which are not similar at all. A unit takes the following form:</p>

<script type="math/tex; mode=display">g(\boldsymbol{w}^T\boldsymbol{x} + b) = y</script>

<p>Where <script type="math/tex">g</script> is some activation function</p>

<h3 id="layer">Layer</h3>

<p>A layer in the context of an MLP is a linear transformation followed by an activation function. A bunch of neurons together on the same level make a layer.</p>

<p>In this post we defined a 2 layer MLP.</p>
<ul>
  <li>Layer 1: Linear transformation <script type="math/tex">\boldsymbol{Wx} + \boldsymbol{b} = z \rightarrow</script> Activation function <script type="math/tex">\rightarrow \sigma(z) = \boldsymbol{h}</script></li>
</ul>

<p><script type="math/tex">\boldsymbol{h} = \sigma(\boldsymbol{Wx} + \boldsymbol{b})</script></p>
<ul>
  <li>Layer 2: <script type="math/tex">\sigma(\boldsymbol{w}_{m}^T\boldsymbol{h} + b_{m})</script></li>
</ul>

<p>People refer to the layers before the last layer as hidden layers. In this case we only had one hidden layer (Layer 1).</p>

<p><strong>More layers</strong>
In practice we usually have many such layers each connected to each other, i.e the output of one becomes the input for to next one. Chaining layers like this is actually the same as function composition. If we define each layer as a function, <script type="math/tex">f_i(x) = g(\boldsymbol{W}_i\boldsymbol{x}+b_i)</script>, where <script type="math/tex">g</script> is some non-linear activation then an n-layer MLP can be written as the function composition <script type="math/tex">MLP(x) = f_n(f_{n-1}(...(f_1(x)))</script>. The depth of a network corresponds to <script type="math/tex">n</script>. A network with depth <script type="math/tex">n > 2</script>, is called deep (this is where the term deep learning comes from). The width of a network corresponds to the number of units in each of the layer.</p>

<h3 id="graph">Graph</h3>

<p>You may have been confused about the fact that MLP is called a neural network. So far we haven‚Äôt seen any neurons or networks. Well, we actually have, but we just avoided to call them that. The MLP that we defined can equivalently be represented by a directed acyclic graph (DAG).</p>

<p><img src="../images/nn.png" alt="" /></p>

<p>All of the edges correspond to the weights (parameters) of the model. The nodes represent computation. For example <script type="math/tex">h_1</script> represents the following computation:</p>

<script type="math/tex; mode=display">h_{1} = \sigma(\boldsymbol{w}_{1}^T\boldsymbol{x} + b_{1})</script>

<p>Remember that previously we computed <script type="math/tex">\boldsymbol{h}</script> in one operation <script type="math/tex">\boldsymbol{h} = \sigma(\boldsymbol{Wx} + \boldsymbol{b})</script>, but now we have three operations:</p>

<p><script type="math/tex">h_{1} = \sigma(\boldsymbol{w}_{1}^T\boldsymbol{x} + b_{1})</script> <br />
<script type="math/tex">h_{2} = \sigma(\boldsymbol{w}_{2}^T\boldsymbol{x} + b_{2})</script> <br />
<script type="math/tex">h_{3} = \sigma(\boldsymbol{w}_{3}^T\boldsymbol{x} + b_{3})</script></p>

<p>These are obviously equivalent, we‚Äôre just using a different representation.</p>

<p>To make sense of the edges, let‚Äôs highlight a single classifier <script type="math/tex">(\boldsymbol{w_1}, b_{1}</script>:</p>

<p>The bolded arrows are the weights that correspond to <script type="math/tex">(\boldsymbol{w_1}, b_{1}</script>.</p>

<p>A layer in the context of an MLP is a linear transformation followed by an activation function. A bunch of neurons together on the same level make a layer. The collection of units on the leftmost side is called the input layer, the units on the rightmost side is called the output layer. Everything in between is referred to as the hidden layer.</p>

<hr />

<p>Here‚Äôs a link to the Jupyter notebook that contains all the code for this post: <a href="https://github.com/colonialjelly/multilayer-perceptron/blob/master/multilayer-perceptron.ipynb">Code</a></p>

<h2 id="footnotes">Footnotes</h2>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>To simplify the notation I‚Äôm referring to all of the parameters <script type="math/tex">\boldsymbol{w}_{m}, b_{m}, \boldsymbol{W}, \boldsymbol{b}</script> with just <script type="math/tex">\theta</script>.¬†<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>What we have written here is the negative log-likelihood. Some people refer to this loss function as binary cross-entropy loss. These are equivalent loss functions, the only difference is the method/assumptions that one uses to arrive at each.¬†<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>There are downsides to this, I‚Äôll write a post about this in the future (hopefully).¬†<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET