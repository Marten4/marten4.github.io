<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <generator uri="http://jekyllrb.com" version="4.0.1">Jekyll</generator>
  
  
  <link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" />
  <updated>2020-05-25T01:13:27+00:00</updated>
  <id>http://localhost:4000//</id>

  
    <title type="html">Giorgi Kvernadze</title>
  

  
    <subtitle>Minimal, responsive Jekyll theme for hackers.</subtitle>
  

  
    <author>
        <name>Giorgi Kvernadze</name>
      
      
    </author>
  

  
  
    <entry>
      
      <title type="html">Min Hashing</title>
      
      
      <link href="http://localhost:4000/blog/minhashing/" rel="alternate" type="text/html" title="Min Hashing" />
      
      <published>2020-03-10T00:00:00+00:00</published>
      <updated>2020-03-10T00:00:00+00:00</updated>
      <id>http://localhost:4000/blog/minhashing</id>
      <content type="html" xml:base="http://localhost:4000/blog/minhashing/">&lt;p&gt;Suppose you’re an engineer at Spotify and you’re on a mission to create a feature that lets users explore new artists that are similar to the ones they already listen to. The first thing you need to do is represent the artists in such a way that they can be compared to each other. You figure that one obvious way to characterize an artist is by the people that listen to it. You decide that each artist shall be defined as a set of user IDs of people that have listened to that artist at least once. For example, the representation for Miles Davis could be,&lt;/p&gt;

\[\text{Miles Davis} = \{5, 23533, 2034, 932, ..., 10003243\}\]

&lt;p&gt;The number of elements in the set is the number of users that have listened to Miles Davis at least once. To compute the similarity between artists, we can compare these set representations. Now, with Spotify having more than 271 million users, these sets could be very large (especially for popular artists). It would take forever to compute the similarities, especially since we have to compare every artist to each other. In this post, I’ll introduce a method that can help us speed up this process. We’re going to be converting each set into a smaller representation called a signature, such that the similarities between the sets are well preserved.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;!-- We're going to do something different instead. Instead of representing the artist as a set of all of the users, that listen to it.

In this post, we're going to talk about how to speed up the process of computing the similarities between these sets. --&gt;

&lt;!-- That is, you compute the ratio between the size of the intersection of the sets and the union. This --&gt;

&lt;!-- Suppose we want to cluster similar artists on Spotify. With about 271 million artists, if we assume that each artist has about 1000 songs in their listening history we would need ~4.33 terabytes to represent the entire data. That is a lot! To make things even worse, in order to find the clusters with $$n$$ artists, we need to measure the similarity between all $${n \choose 2} = \frac{n(n - 1)}{2}$$ pairs of artists. With 271 million artists that is an astronomical number of comparisons!

In this post, the goal will be to reduce the size of the representation of each artist while preserving the similarities. This will take care of the memory issue and some of the computational burden. In the next post, we'll talk about what to do with the bigger computational problem of calculating similarities between all of the pairs of artists. --&gt;

&lt;!--
Measuring similarity of objects is one of the most fundamental computations for data mining. Similarity can be used to detect plagiarism, categorize documents, recommend products to customers and there are many many more applications. There are a lot of different ways of defining similarity. In this post I'll be talking about Jaccard similarity and its' approximation. --&gt;

&lt;h3&gt;Toy Example&lt;/h3&gt;

&lt;p&gt;I think working with tiny examples to build intuition can be an excellent method for learning. In that spirit, now consider a toy example. Assume that we only have 3 artists and we have a total of 8 users in our dataset.&lt;/p&gt;

\[\text{artist}_{1} = \{1, 4, 7\}\]

\[\text{artist}_{2} = \{0, 1, 2, 4, 5, 7\}\]

\[\text{artist}_{3} = \{0, 2, 3, 5, 6\}\]

&lt;!-- I think working with tiny examples to build intuition is an excellent method for learning. So in that spirit, let's consider a toy example. Let's assume that we only have 3 artists and we have a total of 8 songs in our dataset. --&gt;

&lt;!-- ![](../images/artist_data.png) --&gt;

&lt;h3&gt;Jaccard similarity&lt;/h3&gt;

&lt;p&gt;The goal is to find similar artists, so we need a way to measure similarities between a pair of artists. We will be using Jaccard similarity, it is defined as the fraction of shared elements between two sets. In our case the sets are user ids. All we have to compute is how many users each pair of artists share, divided by total number of users in both artists. For example, the Jaccard similarity between \(\text{artist}_1\) and \(\text{artist}_2\):&lt;/p&gt;

&lt;!-- To compute the similarities, we said that we were going to measure the fraction of shared users for each artist. This computation actually has a name, it's called the Jaccard similarity. For a pair of artists, we compute the Jaccard similarity by counting the number of users that are shared and dividing it by the total number of users in both of the artist sets. For example the Jaccard similarity between $$\text{artist}_{1}$$ and $$\text{artist}_{2}$$ --&gt;

&lt;!-- [^renamed_artists]: To make things a little easier to write, I'll refer to the artists by their subscripts from now on. For example. $$\text{artist}_{A} \rightarrow A$$ and so on. --&gt;

&lt;!-- The goal is to cluster similar artists, so we obviously need a way to measure similarities between a pair of artists. We will be using Jaccard similarity. It is defined as the fraction of shared elements between two sets. In our case the sets are artists' listening history. All we have to compute is how many songs each pair of artists share with each other, divided by total number of songs in both artists. For example the Jaccard similarity between $$\text{artist}_1$$ and $$\text{artist}_2$$ --&gt;

\[J(\text{artist}_{1}, \text{artist}_{2}) = \frac{|\text{artist}_{1} \cap \text{artist}_{2}|}{|\text{artist}_{1} \cup \text{artist}_{2}|} = \frac{|\{1, 4, 7\}|}{|\{0, 1, 2, 4, 5, 7\}|} = \frac{3}{6} = 0.5\]

&lt;p&gt;Similarly for the other pairs, we have:&lt;/p&gt;

&lt;center&gt;
$$J(\text{artist}_{2}, \text{artist}_{3}) = \frac{3}{8} = 0.375$$
$$J(\text{artist}_{1}, \text{artist}_{3}) = \frac{0}{8} = 0$$
&lt;/center&gt;

&lt;p&gt;A few key things about the Jaccard similarity:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The Jaccard similarity is 0 if the two sets share no elements, and it’s 1 if the two sets are identical. Every other case has values between 0 and 1.&lt;/li&gt;
  &lt;li&gt;The Jaccard similarity between two sets corresponds to the probability of a randomly selected element from the union of the sets also being in the intersection.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s unpack the second one, because it’s definitely the most important thing to know about the Jaccard similarity.&lt;/p&gt;

&lt;!-- An important fact about the Jaccard similarity is that it corresponds to the probability that a randomly selected element in the union is also in the intersection. This is a crucial property of the Jaccard similarity that is central to understanding why min hashing works. --&gt;

&lt;h3&gt;Intuition behind the Jaccard similarity&lt;/h3&gt;

&lt;p&gt;For some people (present company included), visual explanations are easier to grasp than algebraic ones. We’ll briefly shift our view from sets to Venn diagrams. Let’s imagine any two artists as Venn diagrams, the Jaccard similarity is the size of the intersection divided by the size of the union:&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/js_venn.png&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now imagine that I’m throwing darts on the diagrams and I’m horrible at it. I’m so bad that every element on the diagrams has an equal chance of being hit. What’s the chance that I throw a dart and it lands on the intersection? It would be the number of elements in the intersection divided by the total number of elements, which is exactly what the Jaccard similarity is. This implies that the larger the similarity, the higher the probability that we land on the intersection with a random throw.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/venns.png&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Consider another scenario. Suppose you want to know the similarity between two sets, but you can’t see the diagram, you’re blindfolded. However, if you throw a dart, you do get the information on where it landed. Can you make a good guess on the similarity of two sets by randomly throwing darts on it? Let’s say after throwing 10 darts we know that 6 of them landed in the intersection. What would you guess that the similarity of the two sets are? Let’s say after throwing 40 more darts, we know that 30 of the total 50 throws landed in the intersection. What would your guess be now? Are you more certain about your guess? Why?&lt;/p&gt;

&lt;p&gt;Ponder about this for a little bit and keep this picture in mind throughout reading this post. This is, in essence, the basis for the MinHash algorithm.&lt;/p&gt;

&lt;h3&gt;Approximate Jaccard similarity&lt;/h3&gt;

&lt;p&gt;In the previous paragraph, we have alluded to the fact that it’s possible to approximate the Jaccard similarity between two sets. In order to see why that’s true, we need to rehash some of things we’ve said, mathematically.&lt;/p&gt;

&lt;p&gt;Let’s take \(\text{artist}_1\) and \(\text{artist}_2\) and their union \(\text{artist}_1 \cup \text{artist}_2 = \{0, 1, 2, 4, 5, 7\}\).
Some of the elements in union are also in the intersection, more specifically \(\{1, 4, 7\}\).&lt;/p&gt;

&lt;p&gt;Let’s replace the elements with the symbols “-“ and “+”, denoting if an element appears in the intersection or not.&lt;/p&gt;

\[\{0, 1, 2, 4, 5, 7\} \rightarrow \{-, +, -, +, -, +\}\]

&lt;p&gt;If every element has an equal probability of being picked, what is the probability of drawing an element that is of type “+”? It’s the number of pluses divided by number of pluses and number of minuses.&lt;/p&gt;

\[P(\text{picking a &quot;+&quot;}) = \frac{\text{number of &quot;+&quot;}}{\text{number of &quot;+&quot; and &quot;-&quot;}}\]

&lt;p&gt;The number of “+” corresponds to the number of elements in the intersection and the number of “+” and the number of “-“ corresponds to the total number of elements or the size of the union. Therefore,&lt;/p&gt;

\[P(\text{picking a &quot;+&quot;}) = \frac{\text{number of &quot;+&quot;}}{\text{number of &quot;+&quot; and &quot;-&quot;}} = \frac{|\{1, 4, 7\}|}{|\{0, 1, 2, 4, 5, 7\}|} = J(\text{artist}_1, \text{artist}_2)\]

&lt;!-- More than two sets:

If we have more than two sets some things change. Now we can have multiple intersections. Just knowing that a dart landed in an intersection is not enough, we need to keep track of all possible intersections between the sets. This might be too much of a hassle. So we're gonna change the game.

Imagine that you're at a carnival and there's a shooting game. There are n diagrams on the board, you are again blindfolded. The game is to shoot for k rounds and guess the similarities between all the sets with **some** tolerance for error. Each round consists of up to n throws of a dart. Let's imagine that each throw has a guarantee to hit at least one diagram but it could potentially hit more than one (if it lands in an intersection). After a diagram gets hit, it gets eliminated. The round is over when all of the diagrams are eliminated. The diagrams get reset after each round. As before, you get to know where the dart lands, that is, you get to know the exact element that you hit and which of the diagrams were eliminated. Can you come up with a way to guess the similarities between all of the pairs of sets? --&gt;

&lt;!-- Let $$X$$ be a random variable such that $$X=1$$ if we draw a plus and $$X=0$$ if we draw a minus.

$$\mathbb{E}[X] = P(X=1) \times 1 + P(X=0) \times 0 = 0.5 = J(\text{artist}_{1}, \text{artist}_{2})$$ --&gt;

&lt;p&gt;What this means is that we can approximate the Jaccard similarity between pairs of artists. Let \(X\) be a random variable such that \(X = 1\) if we draw a plus and \(X = 0\) if we draw a minus. \(X\) is a Bernoulli random variable with \(p=J(\text{artist}_{1}, \text{artist}_{2})\). In order to estimate the similarity, we can estimate \(p\). In this case, we obviously know that \(p=0.5\) since we already computed it, but let’s assume that we don’t know this.&lt;/p&gt;

&lt;p&gt;If we repeat the random draw multiple times and keep track of how many times a “+” type came up versus a “-“, we can estimate the parameter \(p\) for \(X\) by maximum likelihood estimation (MLE):&lt;/p&gt;

\[\hat{p}  = \frac{1}{n} \sum_{i=1}^{n} X_{i} = \hat{J}(\text{artist}_{1}, \text{artist}_{2})\]

&lt;p&gt;Where \(X_{i}\) are our observations and \(n\) is the total number of draws that were made. The larger the number of draws \(n\), the better the estimation will be.&lt;/p&gt;

&lt;p&gt;The code below will simulate the process a 30 times and empirically compute the similarity.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;num_trials&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Union of artist_1 and artist_2
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Intersection of artist_1 and artist_2
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intersection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Randomly pick element
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;draws&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_trials&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;num_intersect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_nonzero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;draws&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intersection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_intersect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;draws&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you run the above code you should get something that is close to \(0.5\). Which, as expected, corresponds to the Jaccard similarity between \(\text{artist}_1\) and \(\text{artist}_2\). Play around with the variable \(\text{num_trials}\), what happens if you set it to 1? What about 10,000?&lt;/p&gt;

&lt;!-- So what does this mean? This means that we can approximate Jaccard similarity using randomness. We're going to be using this fact to come up with a way to encode the original data into a smaller representation called a *signature* such that the Jaccard similarities are well approximated.  --&gt;

&lt;!-- This means that this random process in expectation is the same as the Jaccard similarity. We're going to be using this fact to come up with a way to encode the original data into a smaller representation such that the Jaccard similarities are well approximated. --&gt;

&lt;!-- Just to restate the goal, we have a dataset $$D$$ that we want to encode in some smaller dataset $$D^{'}$$ such that $$J_{pairwise}(D) \approx J_{pairwise}(D^{'})$$. Where $$J_{pairwise}$$ is the pairwise Jaccard similarity of all artists in the data. --&gt;

&lt;!-- This is great, but we need to compute similarities between all pairs of artists not just two artists. --&gt;

&lt;h3&gt;Shuffling and Picking First \(\equiv\) Randomly Picking&lt;/h3&gt;

&lt;p&gt;Before we move on, we need to understand one more thing. Randomly selecting an element from a set is the same thing as shuffling the set and picking the first element &lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. Everything that we have said above is also true if we, instead of randomly selecting an element, shuffled the set and picked the first element.&lt;/p&gt;

&lt;!-- Make sure to pause here, if this doesn't make sense. --&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;num_trials&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Union of artist_1 and artist_2
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Intersection of artist_1 and artist_2
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intersection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Shuffle and pick first element
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_intersect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_trials&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intersection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;num_intersect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_intersect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_trials&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The code above implements the same process that I described before, but instead of randomly picking an element, it is shuffling the elements in the union and picking the first element. If you run this, you should similarly get something that is close to \(0.5\).&lt;/p&gt;

&lt;h3&gt;Data Matrix&lt;/h3&gt;

&lt;p&gt;We have shown that it’s possible to approximate Jaccard similarity for a pair of artists using randomness but our previous method had a significant issue. We still needed to have the intersection and the union of the sets to estimate the Jaccard similarity, which kind of defeats the whole purpose. We need a way to approximate the similarities without having to compute these sets. We also need to approximate the similarities for all pairs of artists, not just a given pair. In order to do that, we’re going to switch our view of the data from sets to a matrix.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/artist_matrix.png&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The columns represent the artists and the rows represent the user IDs. A given artist has a \(1\) in a particular row if the user with that ID has that artist in in their listening history &lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3&gt;Min Hashing&lt;/h3&gt;

&lt;p&gt;Going back to our main goal, we want to reduce the size of the representation for each artist while preserving the Jaccard similarities between pairs of artists in the dataset. In more “mathy” terms, we have a data matrix \(D\) that we want to encode in some smaller matrix \(\hat{D}\) called the signature matrix, such that \(J_{pairwise}(D) \approx \hat{J}_{pairwise}(\hat{D})\)&lt;/p&gt;

&lt;!-- To reiterate the goal, we want to encode the data into a smaller representation such that the Jaccard similarities are preserved. In more &quot;mathy&quot; terms, we have a data matrix $$D$$ that we want to encode in some smaller matrix $$\hat{D}$$ called the signature matrix, such that $$J_{pairwise}(D) \approx \hat{J}_{pairwise}(\hat{D})$$ [^4].

[^4]: $$J_{pairwise}$$ is a function that produces a matrix which represents all pairwise similarities of the artists in the data. --&gt;

&lt;p&gt;The first algorithm I will be describing is not really practical but it’s a good way to introduce the actual algorithm called MinHash. The whole procedure can be summarized in a sentence: shuffle the rows of the data matrix and for each artist (column) store the ID of the first non-zero element. That’s it!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;naive-minhashing&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for k iterations
  shuffle rows
  for each column
    store the ID of first non-zero element into the signature matrix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Let’s go through one iteration of this algorithm:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/1iteration.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We have now reduced each artist to a single number. To compute the Jaccard similarities between the artists we compare the signatures. Let \(h\) be the function that finds and returns the index of the first non-zero element. Then we have:&lt;/p&gt;

&lt;center&gt;
$$h(\text{artist}_{1}) = 7$$
$$h(\text{artist}_{2}) = 0$$
$$h(\text{artist}_{3}) = 0$$
&lt;/center&gt;

&lt;p&gt;And the Jaccard similarities are estimated as  &lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

\[\hat{J}(\text{artist}_{i}, \text{artist}_{j}) = \unicode{x1D7D9}[h(\text{artist}_{i}) = h(\text{artist}_{j})]\]

&lt;p&gt;&lt;strong&gt;Why would this work?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To understand why this is a reasonable thing to do, we need to recall our previous discussion on approximating the Jaccard similarity. We were drawing elements from the union of two sets at random and checking if that element appeared in the intersection. What we’re doing here might look different, but it’s actually the same thing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We are shuffling the rows (thus bringing in randomness)&lt;/li&gt;
  &lt;li&gt;By picking the first non-zero element for every artist, we’re always picking an element from the union (for any pair of artists).&lt;/li&gt;
  &lt;li&gt;By checking if \(h(\text{artist}_{i}) = h(\text{artist}_{j})\) we are checking if the element is in the intersection&lt;/li&gt;
  &lt;li&gt;And most importantly the probability of a randomly drawn element being in the intersection is exactly the Jaccard similarity, that is, \(P(h(\text{artist}_{i}) = h(\text{artist}_{j})) = J(\text{artist}_{i}, \text{artist}_{j})\)&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- for any two sets, we're always sampling from the union, and when do we have a success? When both of the rows have a one, i.e $$h(\text{artist}_{i}) = h(\text{artist}_{j})$$ i.e++ the element is in the intersection. Sound familiar?  

Let $$Y$$ be a random variable that is 1 if $$h(\text{artist}_{i}) = h(\text{artist}_{j})$$ and is 0 otherwise. Now what's $$p = P(h(\text{artist}_{i}) = h(\text{artist}_{j}))$$, it is none other than $$J(\text{artist}_{i}, \text{artist}_{j})$$, that is, we're claiming that

$$P(h(\text{artist}_{i}) = h(\text{artist}_{j})) = J(\text{artist}_{i}, \text{artist}_{j})$$ --&gt;

&lt;!-- $$Y$$ is a Bernouli random variable with parameter $$p = J(\text{artist}_{i}, \text{artist}_{j})$$. Hopefully, things should be coming back now. How can we estimate $$p$$, the same way as before. We do multiple trials and estimate $$p$$ as the average. --&gt;

&lt;!-- $$\hat{J}(\text{artist}_{i}, \text{artist}_{j}) = \frac{1}{k}\sum_{l=1}^{k} = \unicode{x1D7D9}[h_{l}(\text{artist}_{i}) = h_{l}(\text{artist}_{j})]$$ --&gt;

&lt;!-- The probability that $$h(\text{artist}_{i})$$ and $$h(\text{artist}_{j})$$ are the same is exactly $$J(\text{artist}_{i}, \text{artist}_{j})$$. That is, we're claiming that $$P(h(\text{artist}_{i}) = h(\text{artist}_{j})) = J(\text{artist}_{i}, \text{artist}_{j})$$. What this means is that, if a pair of artists have a high similarity, there is a high probability they will have the same value for $$h$$. Do you remember throwing darts at the diagrams? The intuition is the same here. --&gt;

&lt;p&gt;Let’s go through an example together with sets \(\text{artist}_{1}\) and \(\text{artist}_{2}\). I’ve highlighted the relevant rows using the same definition for the symbols “+” and “-“ as before. We have an additional symbol called “null”, these correspond to elements that are in neither of the selected artists. The “null” type rows can be ignored since they do not contribute to the similarity (and they are skipped over in the algorithm).&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/artist_matrix_highlighted.png&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If we shuffled the rows what is the probability that the first &lt;strong&gt;non&lt;/strong&gt;-“null” row is of type “+”? In other words, after shuffling the rows, if we proceeded from top to bottom while skipping over all “null” rows, what is the probability of seeing a “+” before seeing a “-“?&lt;/p&gt;

&lt;p&gt;If we think back to our example with sets, this question should be easy to answer. All we have to realize is that,
encountering a “+” before a “-“ is the exact same thing as randomly drawing a “+” in the union, which we know has a probability that is equal to the Jaccard similarity.&lt;/p&gt;

\[P(\text{seeing a &quot;+&quot; before &quot;-&quot;})  = \frac{\text{number of &quot;+&quot;}}{\text{number of &quot;+&quot; and &quot;-&quot;}} = J(\text{artist}_{1}, \text{artist}_{2})\]

&lt;p&gt;If the first row is of type “+” that also means that \(h(\text{artist}_{1}) = h(\text{artist}_{2})\), so the above expression is equivalent to saying:&lt;/p&gt;

\[P(h(\text{artist}_{1}) = h(\text{artist}_{2})) = J(\text{artist}_{1}, \text{artist}_{2})\]

&lt;p&gt;The same argument holds for any pair of artists. The most important take away here is that if the Jaccard similarity is high between two pairs of sets, then the probability that \(h(\text{artist}_{i}) = h(\text{artist}_{j})\) is also high. Remember, throwing darts at the diagrams? It’s the same intuition here.&lt;/p&gt;

&lt;p&gt;Now going back to our example. With a single trial we have the following estimations.&lt;/p&gt;

&lt;!-- So $$Y$$ is a Bernoulli random variable with parameter $$p = J(\text{artist}_{i}, \text{artist}_{j})$$. How can we estimate $$p$$, the same way we did before, by simulating multiple trials and taking the average. --&gt;

&lt;!-- Remember, throwing darts at the diagrams? That's exactly what we're doing here. You can think of this process as throwing a dart on the diagram and then checking if it landed in an intersection. --&gt;

&lt;!-- Going back to our example, we have pairs ($$\text{artist}_1$$, $$\text{artist}_2$$) and ($$\text{artist}_1$$, $$\text{artist}_3$$) having similarity zero since their signatures do not match. The similarity for ($$\text{artist}_2$$, $$\text{artist}_3$$) will be 1 since both have the same signature. --&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/sig1.png&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, it’s a &lt;em&gt;little&lt;/em&gt; off. How can we make it better? It’s simple, we run more iterations and make the signatures larger. In the earlier discussions we introduced a Bernoulli random variable and we estimated it’s parameter by simulating multiple random trials. We can do the same exact thing here. Let \(Y\) be a random variable that has value 1 if \(h(\text{artist}_{i}) = h(\text{artist}_{j})\) and is 0 otherwise. \(Y\) is an instance of a Bernoulli random variable with \(p = J(\text{artist}_{i}, \text{artist}_{j})\). If we run the algorithm multiple times, thus simulating multiple but identical variables \(Y_{1}, Y_{2}, ..., Y_{k}\), we can then estimate the Jaccard similarity as:&lt;/p&gt;

&lt;!-- Remember how we approximated the parameter $$p$$ for the random variable $$X$$? It's the exact same thing here. With a signature with length greater than one the estimation for Jaccard similarity is done by taking the average of each element-wise comparison. --&gt;

\[\hat{J}(\text{artist}_{i}, \text{artist}_{j}) = \frac{1}{k}\sum_{m=1}^{k}Y_{m} = \frac{1}{k}\sum_{l=1}^{k} \unicode{x1D7D9}[h_{m}(\text{artist}_{i}) = h_{m}(\text{artist}_{j})]\]

&lt;p&gt;Where \(h_{m}\) is a function that returns the first non-zero index for iteration \(m\).&lt;/p&gt;

&lt;!-- In the earlier parts of the post, we defined a Bernoulli random variable $$X$$. Do you see similarities to that and what we're doing now? --&gt;

&lt;!-- This is because we're only using a single signature to measure the similarities. This corresponds to only having a single trial in the random experiments we defined previously. As before, the more trials we have, the better the estimation will be.

 We've mentioned before that the more random simulations we run the better the approximation will be. In order to have a better approximation, we should run a few more iterations of this process. This would result in a larger signature matrix. --&gt;

&lt;p&gt;The animation below shows the process of going through 3 iterations of this algorithm:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/minhashing_permuation_animation.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Computing the Jaccard similarities with the larger signature matrix:&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/sig3_sims.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That’s much better. It’s still not exactly the same but it’s not too far off. We’ve managed to reduce the number of rows of the matrix from 8 to 3 while preserving the pairwise Jaccard similarities up to some error. To achieve a better accuracy, we could construct an even larger signature matrix, but obviously we would be trading off the size of the representation.&lt;/p&gt;

&lt;p&gt;If you want to play around with this algorithm, here’s an implementation in Python using Numpy:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;min_hashing_naive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num_artists&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_artists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_artists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;min_hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min_hash&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sig&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3&gt;MinHash Algorithm&lt;/h3&gt;

&lt;p&gt;Shuffling the rows of the data matrix can be infeasible if the matrix is large. In the Spotify example, we would have to shuffle 271 million rows for each iteration of the algorithm. So while the algorithm works conceptually, it is not that useful in practice.&lt;/p&gt;

&lt;p&gt;Instead of explicitly shuffling the rows, what we can instead do is &lt;em&gt;implicitly&lt;/em&gt; shuffle the rows by mapping each row index to some unique integer. There are special functions called hash functions that can do exactly that. They map each unique input to some unique output (usually in the same range).&lt;/p&gt;

\[h: [n] \rightarrow [n]\]

&lt;!-- For example with 8 rows, the hash function could map them to:

$$[0, 1, 2, 3, 4, 5, 6, 7] \rightarrow [4, 1, 5, 6, 0, 2, 3, 7]$$ --&gt;

&lt;p&gt;Although it’s not a necessary for the range of the hash values to be the same as the indices, let’s assume for the sake of this example that it is. Then you can think of these permutations as, &lt;em&gt;where the row would have landed if we actually randomly shuffled the rows&lt;/em&gt;. For example if we had some hash function \(h\) and applied it to row index 4:&lt;/p&gt;

\[h(4) = 2\]

&lt;p&gt;The way you can interpret this is, the row at position 4 got moved to position 2 after shuffling.&lt;/p&gt;

&lt;!-- be generating a random permutation on the indices of the rows. We'll define functions that will take the index of a row as input and will output a random integer such that each row will have a unique integer associated with it. These kinds of functions are called, hash functions.   

What we're going to do instead is *implicitly* shuffle the rows by generating a permutation on the indices of the rows. In order to do this, we're going to introduce hash functions. --&gt;

&lt;!-- A hash function $$h$$ will map every index in the row to some unique integer. Although it's not a necessary for the range of the hash values to be the same as the indices, let's assume for the sake of this example that it is. Then you can think of these permutations as, *where the row would have landed if we actually randomly shuffled the rows*. For example with 8 rows, the hash function could map them to:

$$[0, 1, 2, 3, 4, 5, 6, 7] \rightarrow [4, 1, 5, 6, 0, 2, 3, 7]$$ --&gt;

&lt;p&gt;To simulate multiple iterations of implicit shuffling, we’re going to apply multiple distinct hash functions \(h_{1}, h_{2}, ..., h_{k}\) to each row index.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recipe for generating hash functions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pick a prime number \(p \ge m\) where \(m\) is the number of rows in the dataset. Then each hash function \(h_{i}\) can be defined as:&lt;/p&gt;

\[h_{i}(x) = (a_{i}x + b_{i}) \mod p\]

&lt;p&gt;Where \(a_{i}, b_{i}\) are random integers in the range \([1, p)\) and \([0, p)\), respectively. The input \(x\) to the function is the index of the row. To generate a hash function, all we have to do is pick the parameters \(a\) and \(b\).&lt;/p&gt;

&lt;p&gt;For example, let’s define three hash functions: \(h_{1}, h_{2}, h_{3}\)&lt;/p&gt;

&lt;center&gt;
$$h_{1}(x) = 7x \mod 11$$
$$h_{2}(x) = (x + 5) \mod 11$$
$$h_{3}(x) = (3x + 1) \mod 11$$
&lt;/center&gt;

&lt;p&gt;We’ll be applying these hash functions to the rows of our toy dataset. Since the number of rows \(m = 8\) is not a prime number we chose \(p = 11\). As I’ve mentioned before, the values of the hash function need not be in the same range as the indices. As long as each index is mapped to a unique value, the range of the values actually makes no difference. If this doesn’t make sense to you, let’s unpack the example we have. In this case, our hash functions will produce values in the range \([0, 10]\). We can imagine expanding our dataset with a bunch of “null” type rows so that we have \(p=11\) rows. We know that the “null” rows don’t change the probability of two artists having the same signature, therefore our estimates should be be unaffected.&lt;/p&gt;

&lt;!-- The reason for doing this is because we don't want to have collisions, that is we don't want more than one row to map to the same value for a given hash function. --&gt;

&lt;!-- But what this means is that our hash functions will produce values in the range $$[0, 10]$$, which is larger than your set of indices. This will actually end up not making any difference. To see why we can imagine expanding our dataset with a bunch of &quot;null&quot; type rows so that we have $$m=11$$. We know that the &quot;null&quot; rows don't change the probability of two artists having the same signature, therefore having a range bigger than the actual is not going to change anything. --&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/artist_matrix_hash.png&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Since each hash function defines an implicit shuffling order, we can iterate over the rows in that order. As an exercise, iterate the rows in the defined orders of each hash function. For each column (artist) store the index of the first-non zero element. Then to compute the Jaccard similarities, compare the stored values the same way we did before. &lt;sup id=&quot;fnref:min_index_diff&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:min_index_diff&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The MinHash algorithm is essentially doing the same thing but in a more efficient way by just making a single pass over the rows.&lt;/p&gt;

&lt;!-- Now that we have the hash functions, we're finally ready for the MinHash algorithm: --&gt;

&lt;p&gt;&lt;strong&gt;MinHash&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Initialize all elements in the signature matrix sig to infinity
for each row r in the dataset
  Compute h_{i}(r) for all hash functions h_{1}, h_{2}, ..., h_{k}
  for each non-zero column c in the row r
    if sig(i, c) &amp;gt; h_{i}(r)
      update sig(i, c) = h_{i}(r)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When the algorithm terminates the signature matrix should contain all the minimum hash values for each artist and hash function pair.&lt;/p&gt;

&lt;p&gt;The video below is an animation that simulates the algorithm over the toy dataset. Watching it should hopefully clear up any questions you have about how or why the algorithm works.&lt;/p&gt;

&lt;center&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/qA4WdrY6aPk&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/center&gt;

&lt;p&gt;Now with this algorithm we can reduce all of the artist representations to smaller sets. If we use \(k\) hash functions we will have a signature of size \(k\) for each artist. This means that the time complexity of comparing two sets (artists) is now \(O(k)\), which is independent of the size of the original sets.&lt;/p&gt;

&lt;h3&gt;Next Steps&lt;/h3&gt;

&lt;p&gt;Using the MinHash algorithm, we can reduce the computational complexity of computing similarities between pairs of artists but there is still one more issue. In order to implement the recommendation feature we still need to compute the similarities between every pair of artists. This is quadratic in running time, if \(n\) is the number of artists, we need to make \({n \choose 2} = \frac{n(n-1)}{2} = O(n^2)\) comparisons. If \(n\) is large, even with parallelization, this will be a horribly slow computation.&lt;/p&gt;

&lt;p&gt;We’re in luck because there’s another ingenious method called Locality-sensitive hashing (LSH) that uses the minhash signatures to find candidate pairs. This means that we’ll only have to compute the similarities for the candidates, rather than for every pair. I’ll write about LSH in the next post. Until then, :v:.&lt;/p&gt;

&lt;h2&gt;Further reading&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cs.utah.edu/~jeffp/DMBook/L4-Minhash.pdf&quot;&gt;Min Hashing&lt;/a&gt; - Lecture notes from University of Utah CS 5140 (Data Mining) by Jeff M Phillips. This is were I actually learned about Min Hashing. Answers an important question that I have not addressed in this tutorial, “So how large should we set k so that this gives us an accurate measure?”&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://infolab.stanford.edu/~ullman/mmds/ch3.pdf&quot;&gt;Finding Similar Items&lt;/a&gt; - Chapter 3 of the book “Mining of Massive Datasets” by Jure Leskovec, Anand Rajaraman and Jeff Ullman. Has some really good exercises that are worth checking out.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;If you have any questions or you see any mistakes, please feel free to use the comment section below.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I know shuffling a set of elements is meaningless since sets don’t have order but imagine that they do :). &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In practice this matrix would be very sparse, therefore we wouldn’t store the data in this form, since would be extremely wasteful. But seeing the data as a matrix will be a helpful for conceptualizing the methods that we’re gonna discuss. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The strange looking one (\(\unicode{x1D7D9}\)) is called the indicator function. It outputs a 1 if the expression inside the brackets evaluates to true, otherwise the output is a 0. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:min_index_diff&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;You may notice that the values that get stored are different from what we would store in the naive-min hashing algorithm, will this make any difference? Why? &lt;a href=&quot;#fnref:min_index_diff&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Giorgi Kvernadze</name>
          
          
        </author>
      

      
        <category term="Data Mining" />
      
        <category term="Tutorial" />
      

      

      
        <summary type="html">Suppose you’re an engineer at Spotify and you’re on a mission to create a feature that lets users explore new artists that are similar to the ones they already listen to. The first thing you need to do is represent the artists in such a way that they can be compared to each other. You figure that one obvious way to characterize an artist is by the people that listen to it. You decide that each artist shall be defined as a set of user IDs of people that have listened to that artist at least once. For example, the representation for Miles Davis could be, \[\text{Miles Davis} = \{5, 23533, 2034, 932, ..., 10003243\}\] The number of elements in the set is the number of users that have listened to Miles Davis at least once. To compute the similarity between artists, we can compare these set representations. Now, with Spotify having more than 271 million users, these sets could be very large (especially for popular artists). It would take forever to compute the similarities, especially since we have to compare every artist to each other. In this post, I’ll introduce a method that can help us speed up this process. We’re going to be converting each set into a smaller representation called a signature, such that the similarities between the sets are well preserved.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Multilayer Perceptron</title>
      
      
      <link href="http://localhost:4000/blog/multilayer-perceptron/" rel="alternate" type="text/html" title="Multilayer Perceptron" />
      
      <published>2019-12-19T00:00:00+00:00</published>
      <updated>2019-12-19T00:00:00+00:00</updated>
      <id>http://localhost:4000/blog/multilayer-perceptron</id>
      <content type="html" xml:base="http://localhost:4000/blog/multilayer-perceptron/">&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;This post is best suited for people who are familiar with linear classifiers. I will also be assuming that the reader is familiar with gradient descent.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;The goal of this post isn’t to be a comprehensive guide about neural networks, but rather an attempt to show an intuitive path going from linear classifiers to a simple neural network.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are many types of neural networks, each having some advantage over others. In this post, I want to introduce the simplest form of a neural network, a Multilayer Perceptron (MLP). MLPs are a powerful method for approximating functions and it’s a relatively simple model to implement.&lt;/p&gt;

&lt;p&gt;Before we delve into MLPs, let’s quickly go over linear classifiers. Given training data as pairs \((\boldsymbol{x}_i, y_i)\) where \(\boldsymbol{x}_i \in \mathbb{R}^{d}\) are datapoints (observations) and \(y_i \in \{0, 1\}\) are their corresponding class labels, the goal is to learn a vector of weights \(\boldsymbol{w} \in \mathbb{R}^{d}\) and a bias \(b \in \mathbb{R}\) such that \(\boldsymbol{w}^T\boldsymbol{x}_{i} + b \ge 0\) if \(y_{i} = 1\) and \(\boldsymbol{w}^T\boldsymbol{x}_{i} + b &amp;lt; 0\) otherwise (\(y_{i} = 0\)). This decision can be summarized as the following step function:&lt;/p&gt;

\[\text{Prediction} = \begin{cases}
      1 &amp;amp; \boldsymbol{w}^T\boldsymbol{x} + b \ge 0 \\
      0 &amp;amp;  \text{Otherwise}\\
\end{cases}\]

&lt;p&gt;In the case of Logistic Regression the decision function is characterized by the sigmoid function \(\sigma(z) = \frac{1}{1+e^{-z}}\) where \(z = \boldsymbol{w}^T\boldsymbol{x} + b\)&lt;/p&gt;

\[\text{Prediction} = \begin{cases}
      1 &amp;amp; \sigma(z) \ge \theta \\
      0 &amp;amp;  \text{Otherwise}\\
\end{cases}\]

&lt;p&gt;Where \(\theta\) is a threshold that is usually set to be 0.5.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;!-- *Note: These are actually just a couple of examples of a zoo of functions that people in deep learning literature refer to as activation functions.* --&gt;

&lt;p&gt;If the dataset is linearly separable, this is all fine since we can always learn \(\boldsymbol{w}\) and \(b\) that separates the data perfectly. We’re in good shape even if the dataset isn’t perfectly linearly separable, i.e the data points can be separated with a line barring a few noisy observations.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/blobs.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;But what can we do if the dataset is highly non-linear? For example, something like this:&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/circles.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One thing we could potentially do is to come up with some non-linear transformation function \(\phi(\boldsymbol{x})\), such that applying it renders the data linearly separable. Having this transformation function would allow us to use all the tools we have for linear classification.&lt;/p&gt;

&lt;p&gt;For example, in this case, we can see that the data points come from two concentric circles. Using this information we define the following transformation function: \(\phi(\boldsymbol{x}) = [x_1^2, x_2^2]\)&lt;/p&gt;

&lt;p&gt;Now we can learn a vector \(\boldsymbol{w}\) and bias \(b\) such that \(\boldsymbol{w}^T\phi(\boldsymbol{x}_{i}) + b \ge 0\) if \(y_{i} = 1\) and \(\boldsymbol{w}^T\phi(\boldsymbol{x}_{i}) + b &amp;lt; 0\) otherwise.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/circles_transformed_clf.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This works for this particular case since we know exactly what the data generation process is, but what can we do when the underlying function is not obvious? What if we’re working in high dimensions where we can’t visualize the shape of the dataset? In general, it’s hard to come up with these transformation functions.&lt;/p&gt;

&lt;p&gt;Here’s another idea, instead of learning one linear classifier, let’s try to learn three linear classifiers and then combine them to get something like this:&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/circles3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We know how to learn a single linear classifier but how can we learn three linear classifiers that can produce a result like this? The naive approach would be to try to learn them independently using different random initializations and hope that they converge to something like what we want. However, this approach is doomed from the beginning since each classifier will try to fit the whole data while ignoring what the other classifiers are doing. In other words there will be no cooperation since none of the classifiers will be “aware” of each other. This is the opposite of what we want. We want/need the classifiers to work together.&lt;/p&gt;

&lt;p&gt;This is where MLPs come in. A simple MLP can actually do both of the aforementioned things. It can learn a non-linear transformation that makes the dataset linearly separable and it can learn multiple linear classifiers that cooperate.&lt;/p&gt;

&lt;p&gt;The goal for the next section is to come up with a classifier that can potentially learn how to correctly classify the concentric circles dataset.&lt;/p&gt;

&lt;!-- **Neural Networks:**

By far the most common way of introducing neural networks is with the notion of computational graphs. While I do think that computational graphs are an important concept to understand, I do not think that they are the best way to be introduced to neural networks. Instead I will be using concepts that hopefully you the reader are familiar with. These are the essential operations for neural networks: matrix multiplication, non-linear activation functions and function composition. --&gt;

&lt;!-- In general it's better to teach new ideas using concepts and terms that a person is already familiar with, since this allows for the already known things to function as a foundation to be built on, rather than trying build from scratch.

The term 'neural networks' itself is kind of misleading. It creates an image of a brain like structure and it feeds into the whole hype about AI taking over. Neural networks in reality are nothing but a chain of matrix multiplications followed by non-linear functions.   --&gt;

&lt;h2&gt;Design&lt;/h2&gt;

&lt;h4&gt;Three Linear Classifiers&lt;/h4&gt;

&lt;p&gt;Let’s continue our idea of learning multiple linear classifiers. Define three classifiers \((\boldsymbol{w}_{1}, b_1), (\boldsymbol{w}_{2}, b_3)\) and \((\boldsymbol{w}_{3}, b_3)\), where \(\boldsymbol{w}_i \in \mathbb{R}^2\) and \(b_i \in \mathbb{R}\).&lt;/p&gt;

&lt;p&gt;Because we want to learn all three jointly, it makes sense to combine them into a single object. Let’s stack all of the classifiers into a single matrix \(\boldsymbol{W}^{3 \times 2}\) and the biases into a vector \(\boldsymbol{b}^{3 \times 1}\), as such:&lt;/p&gt;

\[\boldsymbol{W} = \begin{bmatrix}
           \boldsymbol{w}^T_{1} \\
           \boldsymbol{w}^T_{2} \\
           \boldsymbol{w}^T_{3} \\
         \end{bmatrix} = \begin{bmatrix}
                    w_1^{(1)} &amp;amp; w_1^{(2)}\\
                    w_2^{(1)} &amp;amp; w_2^{(2)}\\
                    w_3^{(1)} &amp;amp; w_3^{(2)}\\
                  \end{bmatrix} \boldsymbol{b} = \begin{bmatrix}
                             b_1 \\
                             b_2 \\
                             b_3 \\
                           \end{bmatrix}\]

&lt;p&gt;Now we need to get a classification decision from each one of the classifiers. We mentioned two types of decision functions in the beginning of the post, the step function and the sigmoid, which is basically a smooth step function. For technical reasons that will become clear in the next section, we’re gonna use the sigmoid function to produce decisions. For each pair \((\boldsymbol{w}_{i}, b_i)\), to get the prediction for a given data point we take \(\sigma(\boldsymbol{w}_{i}^T\boldsymbol{x} + b_i)\). This is not taking the advantage of having everything packed into a matrix. Instead of enumerating the classifiers one by one, we could do everything in one operation.&lt;/p&gt;

\[\sigma(\boldsymbol{Wx} + \boldsymbol{b}) = \begin{bmatrix}
\sigma(\boldsymbol{w}_{1}\boldsymbol{x} + b_1) \\
\sigma(\boldsymbol{w}_{2}\boldsymbol{x} + b_2) \\
\sigma(\boldsymbol{w}{3}\boldsymbol{x} + b_3) \\
\end{bmatrix}\]

&lt;p&gt;&lt;em&gt;Note: The \(\sigma\) function for vector valued functions is an element-wise operation.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is great but so far we haven’t really solved anything. We just came up with a neat way to compute the output of all three classifiers given some input. We still need to connect them in order to create “cooperation”.&lt;/p&gt;

&lt;h4&gt;The Meta Classifier&lt;/h4&gt;

&lt;p&gt;Let’s define another linear classifier but this time instead of taking the data points as input, this classifier will take the outputs of the three classifiers as input and will output a final classification decision. In a way it’s a meta classifier since it classifies using outputs of other classifiers.&lt;/p&gt;

&lt;p&gt;Let \(\boldsymbol{h}^{3 \times 1}\) be the output of the previous classifiers, i.e \(\boldsymbol{h} = \sigma(\boldsymbol{Wx} + \boldsymbol{b})\), then the prediction of the meta classifier \((\boldsymbol{w}_{m}, b_{m})\) is defined as: \(\sigma(\boldsymbol{w}_{m}^T\boldsymbol{h} + b_{m})\), where \(\boldsymbol{w}_{m} \in \mathbb{R}^3\) and \(b_{m} \in \mathbb{R}\).&lt;/p&gt;

&lt;p&gt;And there it is, we finally have all the components. All three classifiers are connected, we have a way to produce a single prediction using all three of them and there is hope that coordination will happen because of the meta classifier.&lt;/p&gt;

&lt;p&gt;Just to recap, the expression below is the function that corresponds to our MLP:&lt;/p&gt;

\[\text{MLP}(\boldsymbol{x}; \boldsymbol{w}_{m}, b_{m}, \boldsymbol{W}, \boldsymbol{b}) =\sigma(\boldsymbol{w}_{m}^T\sigma(\boldsymbol{Wx} + \boldsymbol{b}) + b_{m})\]

&lt;p&gt;Everything before the semicolon is the input of the function and everything after are the parameters of the function. Our goal is to learn the parameters.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exercise:&lt;/strong&gt;
A question that you might have at this point is “why do we need to have a decision function applied to the three linear classifiers, can’t we directly plug the outputs to the meta classifier and produce a decision?”. I’m gonna leave the answer to that as an exercise. Remove all the \(\sigma\) functions, and simplify the expression. What do you get? Is it different than having a single linear classifier?&lt;/p&gt;

&lt;h2&gt;Learn&lt;/h2&gt;

&lt;p&gt;We have managed to define a simple MLP but we still need a way to learn the parameters of the function. The function is fully differentiable and this is no accident. As I said earlier, we chose to use the sigmoid function instead of the step-function as a decision function because of technical reasons. Well the technical reason is this: differentiability is nice and we like it because it allows us to use gradient based optimization algorithms like gradient descent.&lt;/p&gt;

&lt;h4&gt;Loss Function&lt;/h4&gt;

&lt;p&gt;Since the function is differentiable, we can define a loss function and then start optimizing with respect to the learnable parameters using gradient descent. Notice that the output of the MLP is a real number between 0 and 1. What we’re essentially doing is modeling the conditional distribution
\(P(y | \boldsymbol{x})\) with a parametrized function \(MLP(\boldsymbol{x}; \theta)\) &lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. This means that we can use the principle of maximum likelihood to estimate the parameters.&lt;/p&gt;

\[L(y, \hat{y}) = \frac{1}{n} \sum_{i=1}^n -y_i\log\hat{y_i} - (1-y_i)\log(1-\hat{y_i})\]

&lt;p&gt;Where \(\hat{y} = MLP(\boldsymbol{x}; \theta)\). The objective is to minimize \(L(y, \hat{y})\) &lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; with respect to the learnable parameters \(\theta\).&lt;/p&gt;

&lt;h4&gt;Optimization&lt;/h4&gt;

&lt;p&gt;The plan is to use gradient descent to optimize \(L\). Remember that during gradient descent, we need take the gradient of the objective at every step of the algorithm (hence the name).&lt;/p&gt;

\[\theta \leftarrow \theta - \alpha \nabla_{\theta} L\]

&lt;p&gt;Where \(\alpha\) is the step size (learning rate).&lt;/p&gt;

&lt;p&gt;Since \(L\) is a composition function, we will need to use the chain rule (from calculus). Furthermore, \(\theta\) isn’t a single variable, we will be optimizing with respect to 4 different variables \(\boldsymbol{w}_{m}, b_{m}, \boldsymbol{W}, \boldsymbol{b}\). We’re going to need to update each one at every step:&lt;/p&gt;

&lt;p&gt;\(\boldsymbol{w}_{m} \leftarrow \boldsymbol{w}_{m} - \alpha * \frac{\partial L}{\partial \boldsymbol{w}_{m}}\) &lt;br /&gt;
  \(b_{m} \leftarrow b_{m} - \alpha * \frac{\partial L}{\partial b_{m}}\) &lt;br /&gt;
  \(\boldsymbol{W} \leftarrow \boldsymbol{W} - \alpha * \frac{\partial L}{\partial \boldsymbol{W}}\) &lt;br /&gt;
  \(\boldsymbol{b} \leftarrow \boldsymbol{b} - \alpha * \frac{\partial L}{\partial \boldsymbol{b}}\)&lt;/p&gt;

&lt;h4&gt;Derivatives, Derivatives, Derivatives&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Skip this section if you don’t care about all of the gory details of computing the partials. Although I do think that it’s a good idea to do this at least once by hand.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now we will need to breakdown each of the partial derivatives using the chain rule. If we don’t give names to intermediate values, it will quickly get hairy. Let’s do that first.&lt;/p&gt;

&lt;p&gt;\(\boldsymbol{s}_1 = \boldsymbol{Wx} + \boldsymbol{b}\) &lt;br /&gt;
  \(\boldsymbol{h} = \sigma(\boldsymbol{s}_1)\) &lt;br /&gt;
  \(s_2 = \boldsymbol{w}^T_{m}\boldsymbol{h} + b_{m}\) &lt;br /&gt;
  \(\hat{y} = \sigma(s_2)\)&lt;/p&gt;

&lt;p&gt;Before we start the tedious process of taking partial derivatives of a composed function, I want to remind you that the goal is to compute these four partial derivatives: \(\frac{\partial L}{\partial \boldsymbol{w}_{m}}, \frac{\partial L}{\partial b_{m}}, \frac{\partial L}{\partial \boldsymbol{W}}, \frac{\partial L}{\partial \boldsymbol{b}}\). If we have these values, we can use them to update the parameters at each step of gradient descent. Using the chain rule we can write down each of the partial derivatives as a product:&lt;/p&gt;

&lt;p&gt;\(\frac{\partial L}{\partial \boldsymbol{w}_{m}} = \frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial \boldsymbol{w}_{m}}\) &lt;br /&gt;
  \(\frac{\partial L}{\partial b_{m}} = \frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial b_{m}}\) &lt;br /&gt;
  \(\frac{\partial L}{\partial \boldsymbol{W}} = \frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial \boldsymbol{h}}\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s}_1}\frac{\partial \boldsymbol{s}_1}{\partial \boldsymbol{W}}\) &lt;br /&gt;
  \(\frac{\partial L}{\partial \boldsymbol{b}} = \frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial \boldsymbol{h}}\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s}_1}\frac{\partial \boldsymbol{s}_1}{\partial \boldsymbol{b}}\)&lt;/p&gt;

&lt;p&gt;I know this looks complex but it really isn’t that complicated. All we’re doing is taking a partial derivative of the loss with respect to each of the learnable parameters. Since the loss is a composition function we have to use chain rule. That’s it.&lt;/p&gt;

&lt;p&gt;We can see that \(\frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\) is shared among all of them and that \(L, \hat{y}, s_2\) are all scalar variables therefore the derivatives are relatively easy to compute.&lt;/p&gt;

&lt;p&gt;\(\frac{\partial L}{\partial \hat{y}} = \frac{\hat{y}-y}{\hat{y}(1-\hat{y})}\) &lt;br /&gt;
  \(\frac{\partial \hat{y}}{\partial s_2} = \hat{y}(1-\hat{y})\) (Recall that \(\sigma^{'}(z) = (1-\sigma(z))\sigma(z)\))&lt;/p&gt;

&lt;p&gt;Hence \(\frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2} = \hat{y}-y\).&lt;/p&gt;

&lt;p&gt;Continuing down the chain we get:&lt;/p&gt;

&lt;p&gt;\(\frac{\partial s_2}{\partial \boldsymbol{w}_{m}} = \boldsymbol{h}\) &lt;br /&gt;
  \(\frac{\partial s_2}{\partial b_{m}} = 1\) &lt;br /&gt;
  \(\frac{\partial s_2}{\partial \boldsymbol{h}} = \boldsymbol{w}_{m}\)&lt;/p&gt;

&lt;p&gt;Now since, \(\boldsymbol{h}\) and \(\boldsymbol{s_1}\) are both vectors, the partial \(\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s_1}}\) will be a matrix; however it will be a diagonal matrix.&lt;/p&gt;

\[\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s_1}} = \text{diag}((\boldsymbol{1} - \boldsymbol{h}) \odot \boldsymbol{h})\]

&lt;p&gt;This can be replaced by an element-wise multiplication in the chain as: \(\odot (\boldsymbol{1} - \boldsymbol{h}) \odot \boldsymbol{h}\)&lt;/p&gt;

&lt;p&gt;The partial derivative \(\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{W}}\) is the most complicated to compute. \(\boldsymbol{s_1}\) is a vector and \(\boldsymbol{W}\) is a matrix, therefore the result of the partial derivative will be a 3 dimensional tensor! Fortunately, we will be able to reduce it to something more simple.&lt;/p&gt;

&lt;p&gt;Instead of computing the partial derivative with respect to entire weight matrix, let’s instead take derivatives with respect to each of the classifiers \(\boldsymbol{w_1}, \boldsymbol{w_2},\) and \(\boldsymbol{w_3}\) (these correspond to the rows of \(\boldsymbol{W}\)). Each of these derivatives will be a matrix instead of a tensor.&lt;/p&gt;

&lt;p&gt;\(\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_1}} = \begin{bmatrix}
             x_1 &amp;amp;&amp;amp; x_2\\
             0 &amp;amp;&amp;amp; 0 \\
             0 &amp;amp;&amp;amp; 0 \\
           \end{bmatrix}\) &lt;br /&gt;
  \(\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_2}} = \begin{bmatrix}
            0 &amp;amp;&amp;amp; 0\\
            x_1 &amp;amp;&amp;amp; x_2 \\
            0 &amp;amp;&amp;amp; 0 \\
          \end{bmatrix}\) &lt;br /&gt;
  \(\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_3}} = \begin{bmatrix}
            0 &amp;amp;&amp;amp; 0\\
            0 &amp;amp;&amp;amp; 0 \\
            x_1 &amp;amp;&amp;amp; x_2 \\
          \end{bmatrix}\)&lt;/p&gt;

&lt;p&gt;We know that we’re gonna be using these values in a multiplication. We can use this fact to simplify the expression for the derivative. Let \(\frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial \boldsymbol{h}}\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s}_1} = \boldsymbol{\delta}\), then we’ll have&lt;/p&gt;

&lt;p&gt;\(\boldsymbol{\delta} \frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_1}} = [\delta_1x_1, \delta_1x_2]\) &lt;br /&gt;
  \(\boldsymbol{\delta} \frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_2}} = [\delta_2x_1, \delta_2x_2]\) &lt;br /&gt;
  \(\boldsymbol{\delta} \frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{w_3}} = [\delta_3x_1, \delta_3x_2]\)&lt;/p&gt;

&lt;p&gt;Which implies that \(\boldsymbol{\delta}\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{W}} = \begin{bmatrix}
          \delta_1x_1 &amp;amp;&amp;amp; \delta_1x_2\\
          \delta_2x_1 &amp;amp;&amp;amp; \delta_2x_2 \\
          \delta_3x_1 &amp;amp;&amp;amp; \delta_3x_2 \\
        \end{bmatrix}\)&lt;/p&gt;

&lt;p&gt;We can rewrite this compactly as an &lt;em&gt;outer product&lt;/em&gt; between \(\boldsymbol{\delta}\) and \(\boldsymbol{x}\).&lt;/p&gt;

\[\frac{\partial L}{\partial \hat{y}}\frac{\partial \hat{y}}{\partial s_2}\frac{\partial s_2}{\partial \boldsymbol{h}}\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{s}_1}\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{W}} = \boldsymbol{\delta} \otimes \boldsymbol{x}\]

&lt;p&gt;And finally,&lt;/p&gt;

\[\frac{\partial \boldsymbol{s_1}}{\partial \boldsymbol{b}} = \text{diag}(\boldsymbol{1}) = \boldsymbol{I}\]

&lt;p&gt;Putting everything together:&lt;/p&gt;

&lt;p&gt;\(\frac{\partial L}{\partial \boldsymbol{w}_{m}} = (\hat{y} - y)\boldsymbol{h}\) &lt;br /&gt;
  \(\frac{\partial L}{\partial b_{m}} = \hat{y} - y\) &lt;br /&gt;
  \(\frac{\partial L}{\partial \boldsymbol{W}} = ((\hat{y} - y)\boldsymbol{w}_{m}\odot (\boldsymbol{1} - \boldsymbol{h}) \odot \boldsymbol{h}) \otimes \boldsymbol{x}\) &lt;br /&gt;
  \(\frac{\partial L}{\partial \boldsymbol{b}} = ((\hat{y} - y)\boldsymbol{w}_{m}\odot (\boldsymbol{1} - \boldsymbol{h}) \odot \boldsymbol{h})^T\)&lt;/p&gt;

&lt;p&gt;You may have noticed that all of this is for a single datapoint \(\boldsymbol{x}\), we wouldn’t do this in practice. It is much more preferable to have everything computed for a batch (or mini-batch) of inputs \(\boldsymbol{X}\), this allows us to update the parameters much more efficiently. I highly recommend you redo all of the computations of the partial derivatives in matrix form.&lt;/p&gt;

&lt;p&gt;I’ve purposefully skipped over a lot of the details. I want this block of the post to serve as a reference for your own solutions rather than a complete step-by-step guide. Here are some useful notes that can come in handy if you want to do everything from scratch:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://cs231n.stanford.edu/vecDerivs.pdf&quot;&gt;Vector, Matrix, and Tensor Derivatives - Erik Learned-Miller&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://web.stanford.edu/class/cs224n/readings/gradient-notes.pdf&quot;&gt;Computing Neural Network Gradients - Kevin Clark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Results&lt;/h2&gt;
&lt;p&gt;Phew! Now that’s over with. Let’s see what the results are after running gradient descent (1000 iterations with a learning rate of 0.01). Do you remember how we started? We said that if only we had a transformation function that could make the dataset linearly separable, then learning would be easy. Well \(\phi(\boldsymbol{x}) = \sigma(\boldsymbol{Wx} + \boldsymbol{b})\) will actually be that transformation that makes the dataset linearly separable. This is what the data looks like after applying that learned function:&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/projection.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see the data is completely linearly separable. In essence, this is what most of learning is when it comes to neural networks. Every neural network classifier that has classification as a primary task is trying to learn some kind of a transformation on the data so that the data becomes linearly separable. This is a big reason why neural networks became so popular. In the past, people (usually domain experts) spent tremendous efforts in engineering features to make learning easy. Now a lot of that is handled by (deep) neural networks &lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;We were also trying to learn multiple linear classifiers. And voilà, these are the three linear classifiers \((\boldsymbol{w}_{1}, b_1), (\boldsymbol{w}_{2}, b_3)\) and \((\boldsymbol{w}_{3}, b_3)\) that are learned:&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/hidden_classifiers.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally this is what the learned decision boundary looks like in the original space. The colors indicate the predictions of the classifier.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/decision_boundary.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is awesome, isn’t it? But wait, hold on. While this classifier gets 100% accuracy, it does not represent the true function… with three classifiers, the shape we are learning is a triangle-ish shape. That’s because it’s the only possible shape that captures all the data with three lines. But we know that the actual function is a circle. With four classifiers we can get rectangle-ish shapes, with five a pentagon-ish and so on. Intuitively, if we add more classifiers, we should get closer to an actual circle. Here’s a progression of the decision boundary going from 5 to 50 with increments of 5:&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/decision_boundaries_progress.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This looks much better. Yet this isn’t really the true function either. Everything in the middle is classified as red, but there will never be any points there. The true function generates points on the boundary of the circle, never inside the circle. Furthermore, the only reason we were able to make this correction was because we’re working in 2 dimensions and we know exactly what the true function is. What do we do if we have a dataset in high dimensions coming from an unknown function? Would we be able to trust the learned classifier even if we get 100% accuracy?&lt;/p&gt;

&lt;h2&gt;Jargon&lt;/h2&gt;

&lt;p&gt;For the entirety of the post, I have purposefully avoided mentioning neural network lingo that you usually see in the literature. I think some of the terms themselves can bring a lot of confusion to people when they first get introduced to neural networks. However, since the field is set on using these terms, it’s necessary to know them. Let’s go back and put names on some of the things we’ve talked about.&lt;/p&gt;

&lt;h3&gt;Activation Functions&lt;/h3&gt;

&lt;p&gt;We talked about decision functions. We mentioned the step function and the sigmoid function. The justification for having them was straight-forward since we were talking in the context of classifiers and we had to have a function that produces a prediction. In the context of neural networks we don’t really care for predictions if it isn’t the last classifier (the meta-classifier). Every intermediate function can have any form, as long as it’s differentiable.&lt;/p&gt;

&lt;p&gt;Because of this, we aren’t constrained to using functions that produce predictions like sigmoid or the step function. Here are a few others we could have used: Tanh, ReLu, LeakyReLu, SoftPlus etc. People refer to these functions as activation functions. The most popular choice in practice is the ReLu activation defined as \(\text{ReLu}(z)=\max(0, z)\). Activation functions are almost always non-linear. The non-linearity is the reason why neural networks are able to learn non-linear functions. When the input is a vector or a matrix, the activation function is applied element-wise.&lt;/p&gt;

&lt;h3&gt;Unit (Neuron)&lt;/h3&gt;

&lt;p&gt;As we mentioned above, we don’t really need to predict in the intermediate operations. Therefore, we probably shouldn’t be calling these functions classifiers. People usually call these functions neurons or units. I prefer to call them units since calling to them neurons is drawing a parallel to biological neurons which are not similar at all. A unit takes the following form:&lt;/p&gt;

\[g(\boldsymbol{w}^T\boldsymbol{x} + b) = y\]

&lt;p&gt;Where \(g\) is some (usually non-linear) activation function.&lt;/p&gt;

&lt;h3&gt;Layer&lt;/h3&gt;

&lt;p&gt;A layer in the context of an MLP is a linear transformation followed by an activation function. A bunch of neurons together on the same level make a layer. What a level means will be more clear when we see the graphical representation of neural networks.&lt;/p&gt;

&lt;p&gt;In this post, we defined a 2 layer MLP.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Layer 1: Linear transformation \(\boldsymbol{Wx} + \boldsymbol{b} = \boldsymbol{s}_1 \rightarrow\) activation \(\rightarrow \sigma(\boldsymbol{s}_1) = \boldsymbol{h}\)&lt;/li&gt;
  &lt;li&gt;Layer 2: Linear transformation \(\boldsymbol{w}_{m}^T\boldsymbol{h} + b_{m} = \boldsymbol{s}_2 \rightarrow\) activation \(\sigma(\boldsymbol{s}_2) \rightarrow \hat{y}\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;People refer to the layers before the last layer as hidden layers. In this case, we only had one hidden layer (Layer 1).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;More layers:&lt;/strong&gt;
In practice, we usually have many such layers with each connected to each other, i.e the output of one becomes the input for to next one. Chaining layers like this is actually the same as function composition. If we define each layer as a function \(f_i(x) = g(\boldsymbol{W}_i\boldsymbol{x} + \boldsymbol{b}_i)\) where \(g\) is some activation function, then an n-layer MLP can be written as the function composition \(MLP(x) = f_n(f_{n-1}(...(f_1(x)))\). The depth of a network corresponds to \(n\). A network with depth \(n &amp;gt; 2\), is called deep (this is where the term deep learning comes from). The width of a network corresponds to the number of units in each of the layer.&lt;/p&gt;

&lt;h3&gt;Graph&lt;/h3&gt;

&lt;p&gt;You may have been confused about the fact that MLP is called a neural network. So far we haven’t seen the “network” part. The MLP that we defined can equivalently be represented by a directed acyclic graph (DAG).&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;/images/nn.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;These kinds of graphs are called computational graphs and they are just another way to describe a neural network model. It provides a good way to break down a complex computation into its’ primitive parts.&lt;/p&gt;

&lt;p&gt;All of the edges correspond to the weights (parameters) of the model. The nodes represent computation. For example, \(h_1\) represents the following computation:&lt;/p&gt;

\[h_{1} = \sigma(\boldsymbol{w}_{1}^T\boldsymbol{x} + b_{1})\]

&lt;p&gt;Edges coming out of the node that have a 1 on it are the biases.&lt;/p&gt;

&lt;p&gt;To make sense of the rest of the edges, let’s highlight a path of a single unit  \((\boldsymbol{w_1}, b_{1})\) to the output:&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;center&quot; src=&quot;../images/nn_single.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This representation is useful for computing gradients. If we wanted to take the derivative of the loss with respect to the first unit, the highlighted path tells us that we have to start from the last output and work our way backwards until we reach the desired variables.&lt;/p&gt;

&lt;p&gt;In this post we calculated all of the gradients by hand but in practice this is done through the algorithm known as backpropagation. It works by repeatedly applying the chain rule to compute all the gradients.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Forward pass:&lt;/strong&gt;
Running through the graph and computing all the values is called the forward pass. It’s called forward pass because we’re traveling from the first layer to the last.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Backward pass:&lt;/strong&gt;
Computing the derivatives of all the parameters with respect to the outputs is called a backward pass. Similar to forward pass, the backward pass is called backward because we’re traversing starting from the last layer and working our way back.&lt;/p&gt;

&lt;h2&gt;Final Words&lt;/h2&gt;

&lt;p&gt;I hope this post has provided some insight to you on how neural networks work. It is by no means comprehensive, I have skipped over a lot of details. If you want to continue learning about neural networks, I would recommend the &lt;a href=&quot;https://www.deeplearningbook.org/&quot;&gt;Deep Learning book by Ian Goodfellow and Yoshua Bengio and Aaron Courville&lt;/a&gt; as a good place to start. Here are a few other good resources:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://playground.tensorflow.org&quot;&gt;Neural Network Playground&lt;/a&gt; - One of the best ways to learn something is to play around with it. The NN playground lets you easily build and train models on various synthetic datasets. Great tool for building intuition.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://cs231n.github.io/&quot;&gt;CS231n: Convolutional Neural Networks for Visual Recognition&lt;/a&gt; - Contains excellent notes from Andrej Karpathy, highly recommended.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cs.toronto.edu/~rgrosse/courses/csc321_2018/&quot;&gt;CSC 321: Intro to Neural Networks and Machine Learning&lt;/a&gt; - This has more than just neural networks. The lecture slides and notes are really good and it builds up from linear classifiers.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&quot;&gt;3Blue1Brown: Neural Networks&lt;/a&gt; - One of my all time favorite educational channels. Has some amazing, visual heavy explanations on the concepts behind neural networks.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h2&gt;Code&lt;/h2&gt;

&lt;p&gt;What’s a tutorial without code, am I right? &lt;a href=&quot;https://github.com/colonialjelly/multilayer-perceptron/blob/master/multilayer-perceptron.ipynb&quot;&gt;Here&lt;/a&gt; is a link to the Jupyter notebook that contains all the code for this post.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;To simplify the notation I’m referring to all of the parameters \(\boldsymbol{w}_{m}, b_{m}, \boldsymbol{W}, \boldsymbol{b}\) with just \(\theta\). &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;What we have written here is the negative log-likelihood. Some people refer to this loss function as binary cross-entropy loss. These are equivalent loss functions, the only difference is the method/assumptions that one uses to arrive at each. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;There are downsides to this, I’ll write a post about this in the future (hopefully). &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Giorgi Kvernadze</name>
          
          
        </author>
      

      
        <category term="Machine Learning" />
      
        <category term="Neural Networks" />
      
        <category term="Tutorial" />
      

      

      
        <summary type="html">This post is best suited for people who are familiar with linear classifiers. I will also be assuming that the reader is familiar with gradient descent. The goal of this post isn’t to be a comprehensive guide about neural networks, but rather an attempt to show an intuitive path going from linear classifiers to a simple neural network. There are many types of neural networks, each having some advantage over others. In this post, I want to introduce the simplest form of a neural network, a Multilayer Perceptron (MLP). MLPs are a powerful method for approximating functions and it’s a relatively simple model to implement. Before we delve into MLPs, let’s quickly go over linear classifiers. Given training data as pairs \((\boldsymbol{x}_i, y_i)\) where \(\boldsymbol{x}_i \in \mathbb{R}^{d}\) are datapoints (observations) and \(y_i \in \{0, 1\}\) are their corresponding class labels, the goal is to learn a vector of weights \(\boldsymbol{w} \in \mathbb{R}^{d}\) and a bias \(b \in \mathbb{R}\) such that \(\boldsymbol{w}^T\boldsymbol{x}_{i} + b \ge 0\) if \(y_{i} = 1\) and \(\boldsymbol{w}^T\boldsymbol{x}_{i} + b &amp;lt; 0\) otherwise (\(y_{i} = 0\)). This decision can be summarized as the following step function: \[\text{Prediction} = \begin{cases} 1 &amp;amp; \boldsymbol{w}^T\boldsymbol{x} + b \ge 0 \\ 0 &amp;amp; \text{Otherwise}\\ \end{cases}\] In the case of Logistic Regression the decision function is characterized by the sigmoid function \(\sigma(z) = \frac{1}{1+e^{-z}}\) where \(z = \boldsymbol{w}^T\boldsymbol{x} + b\) \[\text{Prediction} = \begin{cases} 1 &amp;amp; \sigma(z) \ge \theta \\ 0 &amp;amp; \text{Otherwise}\\ \end{cases}\] Where \(\theta\) is a threshold that is usually set to be 0.5.</summary>
      

      
      
    </entry>
  
  
</feed>
